{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>riweather</code>","text":"<p><code>riweather</code> makes acquiring weather data easier. At its core, it is little more than a wrapper around  NOAA\u2019s Integrated Surface Database (ISD), which provides hourly surface observations from data sources around  the world.</p> <p>With <code>riweather</code>, you can locate the nearest suitable weather station to a certain geographical location and fetch data  from that station for one year or several years. You can opt to retrieve the raw observations, which sometimes occur at  irregular intervals, or you can let <code>riweather</code> do some interpolating and resampling to fit the observations to a  regular time interval of your choosing. Either way, the data is returned in the form of a  Pandas DataFrame or Series so that you can easily incorporate it into the rest of  your analysis pipeline.</p> <p>Move to the next page for installation instructions, and then see it in action on the  Quick How-To page.</p>"},{"location":"cli/","title":"Command Line Interface","text":"<p><code>riweather</code> uses a small database to keep track of the weather stations that exist in NOAA\u2019s Integrated Surface Database (ISD), as well as the years for which there is data at each station. The command line interface lets you rebuild this database from scratch, straight from sources present on the ISD server itself.</p> <p>It\u2019s a good idea to do this periodically because NOAA updates the ISD regularly, and the database in <code>riweather</code> will eventually get out of date as new years and/or weather stations are added.</p> <p>Completely rebuilding the database requires two steps. First, <code>riweather</code> must download a few files from the Internet. These files are:</p> <ul> <li><code>isd-history.csv</code>, containing information about each weather station, including   ID, name, elevation, and location.</li> <li><code>isd-inventory.csv</code>, which records the number of weather observations per station   and per year.</li> <li><code>cb_2020_us_county_500k.zip</code> and <code>cb_2020_us_zcta520_500k.zip</code>, which are   US Census shapefiles describing   the boundaries of counties and Zip Code Tabulation Areas (ZCTAs),   respectively, in the United States.</li> </ul> <p>These files are downloaded to a directory on your computer that you specify when you run <code>riweather download-metadata</code>. The second step is to provide this same directory to <code>riweather rebuild-db</code>. The files will be read and assembled into a SQLite database, also located on your computer, which the package can then use to fetch station information and the like.</p>"},{"location":"cli/#example","title":"Example","text":"<p>To rebuild the database, first run</p> <pre><code>riweather download-metadata -d tmp_riweather_data\n</code></pre> <p>This will create a directory named <code>tmp_riweather_data</code> and download the files into it. Next, run</p> <pre><code>riweather rebuild-db -s tmp_riweather_data\n</code></pre> <p>This could take around 10 minutes to run, so please be patient. Once it finishes, you can delete the <code>tmp_riweather_data</code> folder if you\u2019d like \u2013 those files are no longer needed at this point.</p>"},{"location":"cli/#cli-reference","title":"CLI Reference","text":""},{"location":"cli/#riweather","title":"riweather","text":"<p>Riweather makes grabbing weather data easier.</p> <p>Usage:</p> <pre><code>riweather [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --version  Show the version and exit.\n  --help     Show this message and exit.\n</code></pre>"},{"location":"cli/#riweather-download-metadata","title":"riweather download-metadata","text":"<p>Download weather station and US geography metadata.</p> <p>Pulls files from the Internet that are necessary to (re)build the riweather metadata database.</p> <p>Usage:</p> <pre><code>riweather download-metadata [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -d, --dst DIRECTORY  Directory where the data will be stored.  [required]\n  --help               Show this message and exit.\n</code></pre>"},{"location":"cli/#riweather-rebuild-db","title":"riweather rebuild-db","text":"<p>Drop and recreate all tables in the metadata database.</p> <p>Usage:</p> <pre><code>riweather rebuild-db [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -s, --src DIRECTORY  Directory where the data is stored.  [required]\n  --help               Show this message and exit.\n</code></pre>"},{"location":"how_to/","title":"Quick How-To","text":"<pre><code>import matplotlib.pyplot as plt\nimport riweather\n%matplotlib inline\n</code></pre> <p>Suppose you need weather data at a certain latitude and longitude. To list all weather stations in order of their distance to that site, use <code>riweather.rank_stations</code>.</p> <pre><code>my_lat, my_lon = 39.98, -105.13\nranked_stations = riweather.rank_stations(my_lat, my_lon)\n</code></pre> <pre><code>print(\"Number of stations returned:\", ranked_stations.shape[0])\nranked_stations.head()\n</code></pre> <pre>\n<code>Number of stations returned: 2868\n</code>\n</pre> name distance latitude longitude years quality usaf_id 720534 ERIE MUNICIPAL AIRPORT 7971.794695 40.017 -105.050 [2014, 2015, 2016, 2017, 2018, 2019, 2020, 202... [low, high, high, high, high, high, high, high... 724699 ATCT ROCKY MOUNTAIN METRO 8951.899139 39.900 -105.117 [2006, 2007, 2008, 2009, 2010, 2011, 2012, 201... [medium, medium, medium, medium, high, high, h... 720533 BOULDER MUNICIPAL AIRPORT 9477.070760 40.033 -105.217 [2010, 2011, 2012, 2013, 2014, 2015, 2016, 201... [medium, high, high, high, high, high, high, h... 720538 VANCE BRAND AIRPORT 21002.247034 40.167 -105.167 [2010, 2011, 2012, 2013, 2014, 2015, 2016, 201... [low, high, high, high, high, high, high, high... 725650 DENVER INTERNATIONAL AIRPORT 43134.270016 39.847 -104.656 [2005, 2006, 2007, 2008, 2009, 2010, 2011, 201... [high, high, high, high, high, high, high, hig... <p>This gives us the name and USAF identifiers of all ISD weather stations in the United States, along with their latitudes and longitudes and their distances (in meters) to the target site. The \u201cyears\u201d column is a list of years for which there is available weather data from that station. The \u201cquality\u201d column contains the quality of the data file for the corresponding year\u2014this is based on the number of observations in the file.</p> <p>You probably don\u2019t need all of the thousands of weather stations that are returned, so let\u2019s be more efficient and limit our search to stations that have data for 2024 and are within 20 km of our site.</p> <pre><code>ranked_stations = riweather.rank_stations(\n    my_lat,\n    my_lon,\n    year=2024,\n    max_distance_m=20000,\n)\nranked_stations\n</code></pre> name distance latitude longitude years quality usaf_id 720534 ERIE MUNICIPAL AIRPORT 7971.794695 40.017 -105.050 [2014, 2015, 2016, 2017, 2018, 2019, 2020, 202... [low, high, high, high, high, high, high, high... 724699 ATCT ROCKY MOUNTAIN METRO 8951.899139 39.900 -105.117 [2006, 2007, 2008, 2009, 2010, 2011, 2012, 201... [medium, medium, medium, medium, high, high, h... 720533 BOULDER MUNICIPAL AIRPORT 9477.070760 40.033 -105.217 [2010, 2011, 2012, 2013, 2014, 2015, 2016, 201... [medium, high, high, high, high, high, high, h... <p>Erie Municipal Airport is the closest station. To access its weather data, first create a <code>Station</code> object using its USAF ID.</p> <pre><code>station = riweather.Station(\"720534\")\nstation.name\n</code></pre> <pre>\n<code>'ERIE MUNICIPAL AIRPORT'</code>\n</pre> <p>Alternatively, use <code>riweather.select_station</code>, selecting the first station in the table by passing <code>rank=0</code>.</p> <pre><code>station = riweather.select_station(ranked_stations, rank=0)\nstation.name\n</code></pre> <pre>\n<code>'ERIE MUNICIPAL AIRPORT'</code>\n</pre> <p>Only have a ZIP code for your site and not a precise latitude and longitude? No problem. If you pass a ZIP code to <code>riweather.rank_stations</code> instead of lat/lon, it will rank the weather stations by their distances from the center point of the ZIP code tabulation area (ZCTA).</p> <pre><code>riweather.rank_stations(zipcode=\"80027\").head()\n</code></pre> name distance latitude longitude years quality usaf_id 724699 ATCT ROCKY MOUNTAIN METRO 6901.277347 39.900 -105.117 [2006, 2007, 2008, 2009, 2010, 2011, 2012, 201... [medium, medium, medium, medium, high, high, h... 720533 BOULDER MUNICIPAL AIRPORT 10206.621488 40.033 -105.217 [2010, 2011, 2012, 2013, 2014, 2015, 2016, 201... [medium, high, high, high, high, high, high, h... 720534 ERIE MUNICIPAL AIRPORT 12169.752144 40.017 -105.050 [2014, 2015, 2016, 2017, 2018, 2019, 2020, 202... [low, high, high, high, high, high, high, high... 720538 VANCE BRAND AIRPORT 24009.264942 40.167 -105.167 [2010, 2011, 2012, 2013, 2014, 2015, 2016, 201... [low, high, high, high, high, high, high, high... 724695 BUCKLEY AIR FORCE BASE 43896.481997 39.717 -104.750 [2005, 2006, 2007, 2008, 2009, 2010, 2011, 201... [high, high, high, high, high, high, high, hig... <p>Behind the scenes, this uses the function <code>riweather.zcta_to_lat_lon</code> to determine the center point.</p> <pre><code>my_lat, my_lon = riweather.zcta_to_lat_lon(\"80027\")\nprint(f\"Latitude: {my_lat:.3f}, Longitude: {my_lon:.3f}\")\n</code></pre> <pre>\n<code>Latitude: 39.951, Longitude: -105.164\n</code>\n</pre> <p>We can verify the location of our site and the nearest weather stations by plotting them on an interactive map with <code>riweather.plot_stations</code>. The pin represents the lat/lon site and the cloud icons represent the weather stations. Click on a station to see its name, and click on a line to see the distance between a station and the site.</p> <p>Warning</p> <p>It\u2019s probably not a good idea to plot the entire set of 2,000+ stations on a map. Make sure <code>ranked_stations</code> is filtered down to a reasonable size first.</p> <pre><code>riweather.plot_stations(my_lat, my_lon, ranked_stations, distance_unit=\"mi\")\n</code></pre> Make this Notebook Trusted to load map: File -&gt; Trust Notebook <p>Let\u2019s see how complete we can expect the data to be when we pull it by looking at the quality report.</p> <pre><code>station.quality_report()\n</code></pre> usaf_id wban_id year quality jan feb mar apr may jun jul aug sep oct nov dec count n_zero_months 0 720534 00161 2014 low 0 0 0 0 0 0 2191 2172 1869 2240 2160 2174 12806 6 1 720534 00161 2015 high 2232 1981 2226 2117 2244 2035 2232 2233 2084 2217 2151 2232 25984 0 2 720534 00161 2016 high 2240 2094 2239 2168 2255 2147 2203 2129 2173 2211 2164 2150 26173 0 3 720534 00161 2017 high 2143 1961 2213 2163 2061 2167 2204 2095 2172 2198 2888 2242 26507 0 4 720534 00161 2018 high 2219 2033 2272 2198 2523 2191 2292 2388 2125 2298 2217 2284 27040 0 5 720534 00161 2019 high 2279 2084 2255 2286 2432 2288 1780 1810 2088 2226 2169 2239 25936 0 6 720534 00161 2020 high 2056 2093 2234 2167 2232 2145 2096 2026 2161 2187 2160 2202 25759 0 7 720534 00161 2021 high 2227 2027 2245 2159 2232 2174 2168 2243 2098 2235 2145 2208 26161 0 8 720534 00161 2022 high 2237 2020 2152 2049 2232 2168 2250 2241 2160 2231 2169 2187 26096 0 9 720534 00161 2023 high 2246 2005 2245 2139 2250 2183 2253 2191 2160 2242 2138 2215 26267 0 10 720534 00161 2024 high 2238 1920 2208 2166 2218 2165 2236 2193 2153 2220 1744 2200 25661 0 11 720534 00161 2025 high 1915 0 0 0 0 0 0 0 0 0 0 0 1915 0 <p>The data for 2024 is <code>\"high\"</code> quality, with more than 2,000 observations in each month and no months that are missing. Assuming they are evenly spaced, that corresponds to one observation roughly every 20 minutes.</p> <p>Now we can use <code>riweather.Station.fetch_data</code> to get weather data. We need air temperatures in Fahrenheit for 2024, hour-ending to align with a set of electricity meter readings, in the US Mountain time zone.</p> <pre><code>ts = station.fetch_data(2024, datum=\"air_temperature\", period=\"h\", rollup=\"ending\", tz=\"US/Mountain\", temp_scale=\"F\")\nts\n</code></pre> air_temperature.temperature_f 2023-12-31 18:00:00-07:00 33.176848 2023-12-31 19:00:00-07:00 29.726000 2023-12-31 20:00:00-07:00 25.415750 2023-12-31 21:00:00-07:00 22.736750 2023-12-31 22:00:00-07:00 20.876750 ... ... 2024-12-31 13:00:00-07:00 34.328000 2024-12-31 14:00:00-07:00 35.445500 2024-12-31 15:00:00-07:00 35.640500 2024-12-31 16:00:00-07:00 34.249250 2024-12-31 17:00:00-07:00 31.057455 <p>8784 rows \u00d7 1 columns</p> <pre><code>ts.plot()\nplt.show()\n</code></pre> <p>Other data points may be available as well, depending on the weather station. For example, we can pull wind speed (in meters per second) as well:</p> <pre><code>ts = station.fetch_data(2024, datum=\"wind\", period=\"h\", rollup=\"ending\", tz=\"US/Mountain\")\nts.plot()\nplt.show()\n</code></pre>"},{"location":"how_to/#getting-started-with-riweather","title":"Getting Started With <code>riweather</code>","text":""},{"location":"how_to/#finding-a-weather-station","title":"Finding a weather station","text":""},{"location":"how_to/#finding-a-station-from-a-zip-code","title":"Finding a station from a ZIP code","text":""},{"location":"how_to/#visualizing-weather-stations-on-a-map","title":"Visualizing weather stations on a map","text":""},{"location":"how_to/#fetching-weather-data","title":"Fetching weather data","text":""},{"location":"install/","title":"Installation","text":""},{"location":"install/#with-pip","title":"With pip","text":"<pre><code>pip install riweather\n</code></pre> <p>The basic installation method does not install the packages required for plotting stations with <code>riweather.plot_stations</code>. If you want to make plots, install the optional <code>plots</code> dependencies:</p> <pre><code>pip install \"riweather[plots]\"\n</code></pre>"},{"location":"install/#within-a-pipx-jupyter-environment","title":"Within a <code>pipx</code> Jupyter environment","text":"<p>If you have a <code>pipx</code> environment for local development with Jupyter, then you can inject <code>riweather</code> into that environment and it will be available to your notebooks.</p> <pre><code>pipx inject jupyter riweather\n</code></pre> <p>To update <code>riweather</code> to the latest version published on PyPI, you can uninject it (uninstalling it from your environment) and inject it again:</p> <pre><code>pipx uninject jupyter riweather\npipx inject jupyter riweather\n</code></pre>"},{"location":"install/#if-data-appears-to-be-missing-for-the-current-year","title":"If data appears to be missing for the current year","text":"<p>If you are trying to fetch weather data for a certain year (usually it will be the current year) and you are receiving no results, it could be that the station metadata that is shipped with the <code>riweather</code> package needs to be refreshed. See  the CLI reference page for more details about why this needs to be  done. In a nutshell, you can refresh it manually by running the following from the command line:</p> <pre><code>riweather download-metadata -d tmp_riweather_data\nriweather rebuild-db -s tmp_riweather_data\n</code></pre> <p>This may take a few minutes to run. After it is complete, you can delete the  <code>tmp_riweather_data</code> directory that was created.</p>"},{"location":"resampling/","title":"Data Resampling Introduction","text":"<p>Often, the reason we need temperature data is to explore the relationship between weather and energy use for a particular building, home, or collection of homes. To quantify this relationship, we need both temperature and energy observations to be on the same time scale - whether that is hourly, half-hourly, etc. Unfortunately, however, readings from weather stations aren\u2019t always available at the particular time scale of your meter readings, and indeed, they aren\u2019t even necessarily at regular intervals at all (the NOAA Integrated Surface Dataset has some stations that sometimes emit data every two minutes and sometimes every twenty minutes, for example).</p> <p><code>riweather</code> has some tools to ease the process of aligning temperature data to a certain time scale. It builds on top of the resampling functionality of Pandas. This tutorial illustrates the different options at your disposal, so that you can handle the alignment exactly how you need to.</p> <pre><code>import matplotlib.pyplot as plt\nimport pandas as pd\nimport riweather\n\n%matplotlib inline\n</code></pre> <pre><code>temps = pd.Series(\n    [0, 9, 3, 1, 2, 5, 8, 6, 4, 7],\n    index=pd.date_range(\"2023-01-01 00:15\", periods=10, freq=\"20min\"),\n    name=\"tempC\",\n)\n</code></pre> <pre><code>temps\n</code></pre> <pre>\n<code>2023-01-01 00:15:00    0\n2023-01-01 00:35:00    9\n2023-01-01 00:55:00    3\n2023-01-01 01:15:00    1\n2023-01-01 01:35:00    2\n2023-01-01 01:55:00    5\n2023-01-01 02:15:00    8\n2023-01-01 02:35:00    6\n2023-01-01 02:55:00    4\n2023-01-01 03:15:00    7\nFreq: 20min, Name: tempC, dtype: int64</code>\n</pre> <pre><code>def plot_temps(datasets, labels, raw_idx=0):\n    import matplotlib.dates as mdates\n\n    fig, ax = plt.subplots(figsize=(12, 4))\n    fig.suptitle(\"Temperature resampling\")\n    for i, (d, l) in enumerate(zip(datasets, labels, strict=True)):\n        if i == raw_idx:\n            ax.plot(d, \"D\", color=\"black\", alpha=0.2, label=l)\n        else:\n            ax.plot(d, \"x-\", label=l)\n    ax.xaxis.set_major_formatter(mdates.DateFormatter(\"%I:%M %p\"))\n    ax.set_ylabel(\"Temperature (C)\")\n    _ = ax.legend()\n    plt.show()\n</code></pre> <pre><code>datasets = [temps]\nlabels = [\"Actual observations\"]\n</code></pre> <pre><code>plot_temps(datasets, labels)\n</code></pre> <p>We need to align these temperatures to a dataset of smart meter readings that occur at the top of every hour. How can we do this?</p> <p>One option is to take the average of all readings over the previous hour. So, for 1 AM, the previous hour\u2019s readings were 0, 9, and 3 degrees, and the average is 4. With <code>riweather</code> we can do this with <code>rollup_ending()</code>. The word \u201cending\u201d in the name means that we are calculating \u201chour-ending\u201d values.</p> <p>Because meter readings are typically collected as hour-ending values as well, <code>rollup_ending()</code> is the default behavior of the all-in-one fetching method <code>riweather.Station.fetch_data</code> when a resampling <code>period</code> is specified.</p> <pre><code>temps_ending = riweather.rollup_ending(temps, \"h\", upsample_first=False)\ntemps_ending\n</code></pre> <pre>\n<code>2023-01-01 01:00:00    4.000000\n2023-01-01 02:00:00    2.666667\n2023-01-01 03:00:00    6.000000\n2023-01-01 04:00:00    7.000000\nFreq: h, Name: tempC, dtype: float64</code>\n</pre> <pre><code>datasets.append(temps_ending)\nlabels.append(\"Hourly resampling, hour-ending\")\n</code></pre> <pre><code>plot_temps(datasets, labels)\n</code></pre> <p>You can get hour-starting values instead with <code>rollup_starting()</code>. Notice that the first three readings are still averaged together, but the timestamp assigned to the result is midnight (the start of the hour), instead of 1 AM.</p> <pre><code>temps_starting = riweather.rollup_starting(temps, \"h\", upsample_first=False)\ntemps_starting\n</code></pre> <pre>\n<code>2023-01-01 00:00:00    4.000000\n2023-01-01 01:00:00    2.666667\n2023-01-01 02:00:00    6.000000\n2023-01-01 03:00:00    7.000000\nFreq: h, Name: tempC, dtype: float64</code>\n</pre> <pre><code>datasets.append(temps_starting)\nlabels.append(\"Hourly resampling, hour-starting\")\n</code></pre> <pre><code>plot_temps(datasets, labels)\n</code></pre> <p>Instead of hour-ending or hour-starting values, you might want the range over which the average is taken to extend both forward and backward. Using <code>rollup_midpoint()</code>, the value at 1 AM will be the average over all data between 12:30 and 1:30 AM.</p> <pre><code>temps_midpoint = riweather.rollup_midpoint(temps, \"h\", upsample_first=False)\ntemps_midpoint\n</code></pre> <pre>\n<code>2023-01-01 00:00:00    0.000000\n2023-01-01 01:00:00    4.333333\n2023-01-01 02:00:00    5.000000\n2023-01-01 03:00:00    5.666667\nFreq: h, Name: tempC, dtype: float64</code>\n</pre> <pre><code>datasets.append(temps_midpoint)\nlabels.append(\"Hourly resampling, midpoint\")\n</code></pre> <pre><code>plot_temps(datasets, labels)\n</code></pre> <p>Finally, <code>rollup_instant()</code> does not do any averaging at all. Instead, the value for a certain hour will simply be the first actual data point during that hour.</p> <pre><code>temps_instant = riweather.rollup_instant(temps, \"h\", upsample_first=False)\ntemps_instant\n</code></pre> <pre>\n<code>2023-01-01 00:00:00    0\n2023-01-01 01:00:00    1\n2023-01-01 02:00:00    8\n2023-01-01 03:00:00    7\nFreq: h, Name: tempC, dtype: int64</code>\n</pre> <pre><code>datasets.append(temps_instant)\nlabels.append(\"Hourly resampling, instant\")\n</code></pre> <pre><code>plot_temps(datasets, labels)\n</code></pre> <pre><code>temps_30min_starting = riweather.rollup_starting(temps, \"30min\", upsample_first=False)\ntemps_30min_ending = riweather.rollup_ending(temps, \"30min\", upsample_first=False)\n\ndatasets = [\n    temps,\n    temps_30min_starting,\n    temps_30min_ending,\n]\n\nlabels = [\n    \"Actual observations\",\n    \"Half-hourly resampling, hour-starting\",\n    \"Half-hourly resampling, hour-ending\",\n]\n\nplot_temps(datasets, labels)\n</code></pre> <pre><code>temps2 = pd.Series(\n    [1, 2, 10],\n    index=pd.date_range(\"2023-01-01 00:01\", \"2023-01-01 01:05\", freq=\"32min\"),\n)\ntemps2\n</code></pre> <pre>\n<code>2023-01-01 00:01:00     1\n2023-01-01 00:33:00     2\n2023-01-01 01:05:00    10\nFreq: 32min, dtype: int64</code>\n</pre> <p>There are two observations between 12 AM and 1 AM: 1 degree at 12:01 and 2 degrees at 12:33. If we were to simply take the average in our hour-ending resampling procedure, we would end up with a value of 1.5 degrees at 1 AM.</p> <pre><code>riweather.rollup_ending(temps2, \"h\", upsample_first=False)\n</code></pre> <pre>\n<code>2023-01-01 01:00:00     1.5\n2023-01-01 02:00:00    10.0\nFreq: h, dtype: float64</code>\n</pre> <p>However, we can see that the temperature rose to 10 degrees by 1:05, so it\u2019s safe to say there were some higher temperatures in the second half of the 12 AM hour that were not captured by averaging the two observations we had available, and so 1.5 degrees is likely an underestimate of the average temperature over that period.</p> <p>We can address this problem by first upsampling the observations before resampling them. Upsampling means taking data from one time interval to a finer-grained time interval. In this case, we perform linear interpolation to take the data up to the minute level. This allows us to better capture changes in temperature.</p> <p>You can perform the upsampling step on its own with <code>riweather.upsample</code>:</p> <pre><code>temps2_upsampled = riweather.upsample(temps2, \"min\")\ntemps2_upsampled\n</code></pre> <pre>\n<code>2023-01-01 00:01:00     1.00000\n2023-01-01 00:02:00     1.03125\n2023-01-01 00:03:00     1.06250\n2023-01-01 00:04:00     1.09375\n2023-01-01 00:05:00     1.12500\n                         ...   \n2023-01-01 01:01:00     9.00000\n2023-01-01 01:02:00     9.25000\n2023-01-01 01:03:00     9.50000\n2023-01-01 01:04:00     9.75000\n2023-01-01 01:05:00    10.00000\nFreq: min, Length: 65, dtype: float64</code>\n</pre> <pre><code>plot_temps([temps2, temps2_upsampled], [\"Actual\", \"Upsampled\"])\n</code></pre> <p>In the rollup functions, you can perform the upsampling and resampling all in one step by passing <code>upsample_first=True</code> (this is the default, so you can also just omit it).</p> <pre><code>riweather.rollup_ending(temps2, \"h\")\n</code></pre> <pre>\n<code>2023-01-01 01:00:00    3.3\n2023-01-01 02:00:00    9.5\nFreq: h, dtype: float64</code>\n</pre> <p>The resampled 1 AM value is now 3.3 degrees, up from 1.5 in the other approach.</p> <p>Going back to the first toy example, let\u2019s observe the difference in hour-ending values with and without the initial upsampling:</p> <pre><code>temps_ending_upsampled = riweather.rollup_ending(temps, \"h\", upsample_first=True)\ntemps_ending_not_upsampled = riweather.rollup_ending(temps, \"h\", upsample_first=False)\n\ndatasets = [\n    temps,\n    temps_ending_upsampled,\n    temps_ending_not_upsampled,\n]\n\nlabels = [\n    \"Actual observations\",\n    \"Hour-ending, upsampling\",\n    \"Hour-ending, no upsampling\",\n]\n\nplot_temps(datasets, labels)\n</code></pre> <pre><code>s = riweather.Station(\"720534\")\n</code></pre> <pre><code>temps = s.fetch_data(\n    2024, \n    \"air_temperature\", \n    period=\"h\", \n    rollup=\"ending\", \n    upsample_first=True,\n)\ntemps.head()\n</code></pre> air_temperature.temperature_c air_temperature.temperature_f 2024-01-01 01:00:00+00:00 0.653804 33.176848 2024-01-01 02:00:00+00:00 -1.263333 29.726000 2024-01-01 03:00:00+00:00 -3.657917 25.415750 2024-01-01 04:00:00+00:00 -5.146250 22.736750 2024-01-01 05:00:00+00:00 -6.179583 20.876750 <pre><code>temps_raw = s.fetch_data(2024, \"air_temperature\", include_quality_codes=False)\ntemps_upsampled = riweather.upsample(temps_raw, \"min\")\ntemps_resampled = riweather.rollup_ending(temps_upsampled, upsample_first=False)\n</code></pre> <pre><code>temps_resampled.head()\n</code></pre> air_temperature.temperature_c air_temperature.temperature_f 2024-01-01 01:00:00+00:00 0.653804 33.176848 2024-01-01 02:00:00+00:00 -1.263333 29.726000 2024-01-01 03:00:00+00:00 -3.657917 25.415750 2024-01-01 04:00:00+00:00 -5.146250 22.736750 2024-01-01 05:00:00+00:00 -6.179583 20.876750 <pre><code>\n</code></pre>"},{"location":"resampling/#data-resampling-an-introduction","title":"Data Resampling: An Introduction","text":""},{"location":"resampling/#resampling-strategies-on-a-toy-example","title":"Resampling strategies on a toy example","text":"<p>Suppose we have the following ten weather observations. They occur twenty minutes apart, at 15, 35, and 55 minutes past the hour.</p>"},{"location":"resampling/#the-four-rollup_-functions","title":"The four <code>rollup_*()</code> functions","text":""},{"location":"resampling/#going-beyond-hourly-intervals","title":"Going beyond hourly intervals","text":"<p>Every example of the <code>rolling_*()</code> functions so far has specified <code>\"h\"</code> for the second argument. This is a frequency string from Pandas. You can pass any frequency string to get data resampled at different intervals - see the link for more information on how to use the strings.</p> <p>As another example, we could resample our data to get half-hourly intervals:</p>"},{"location":"resampling/#upsampling-before-resampling","title":"Upsampling before resampling","text":"<p>So far, we have used all of the rollup functions with the parameter <code>upsample_first=False</code>. With this option set, the resampling is done based on the raw values and the raw values only - so, for example, the hour-ending rollup value at 1 AM is precisely the average of all raw values that occurred between 12 AM and 1 AM.</p> <p>This isn\u2019t always the most accurate way to arrive at a single representative value for the entire hour (or half-hour, or whatever the desired time interval is). Consider the following temperatures:</p>"},{"location":"resampling/#fetching-upsampling-and-resampling-from-a-station","title":"Fetching, upsampling, and resampling from a Station","text":"<p>When fetching data from the ISD, you can perform all of the resampling in a single step by passing the appropriate parameters to <code>riweather.Station.fetch_data</code>.</p>"},{"location":"resampling/#customizing-the-resampling-process","title":"Customizing the resampling process","text":"<p>When used in this way, <code>riweather.Station.fetch_data</code> performs three steps:</p> <ol> <li>Fetching data from the ISD at the original time scale</li> <li>Upsample to minute-level (if desired)</li> <li>Resample to the given time interval</li> </ol> <p>Each of these steps is exposed by the <code>riweather</code> API as separate functions, so if you want to directly manipulate the data with Pandas, you may store the intermediate datasets and use them however you want.</p> <p>To recreate the exact steps performed in <code>fetch_data</code>:</p>"},{"location":"about/integrated_surface_dataset/","title":"The Integrated Surface Dataset","text":"<p><code>riweather</code> sources its data from NOAA\u2019s Integrated Surface Data (ISD). The ISD contains surface observations from weather stations around the world. The raw data is freely accessible at this web address:</p> <p>https://www.ncei.noaa.gov/pub/data/noaa/</p> <p>The data files are organized into subfolders by year, and each file contains observations from one station and one year. The URLs are structured like the following:</p> <pre><code>https://www.ncei.noaa.gov/pub/data/noaa/&lt;year&gt;/&lt;usaf_id&gt;-&lt;wban_id&gt;-&lt;year&gt;.gz\n</code></pre> <p>where <code>&lt;year&gt;</code> is the calendar year, and <code>&lt;usaf_id&gt;</code> and <code>&lt;wban_id&gt;</code> are two identifiers representing the station.  For example, one such URL is below.</p> <p>Warning</p> <p>The link below is a direct link to a data file. Clicking it will download the file to your computer.</p> <p>https://www.ncei.noaa.gov/pub/data/noaa/2025/720534-00161-2025.gz</p> <p>You could download the appropriate files and work with them yourself, but you will need to determine the ID of the correct station first. <code>riweather</code> makes that process easier by showing you the IDs and names of the closest  stations to a given latitude and longitude, constructing the URLs properly, and downloading and uncompressing the  files for you.</p>"},{"location":"about/integrated_surface_dataset/#structure-of-the-isd-data","title":"Structure of the ISD data","text":"<p>Each ISD file is a compressed, plaintext, fixed-width file. As an example of what they look like, here are the first  few lines of one of them.</p> <pre><code>0184720534001612024010100154+40017-105050FM-15+156499999V0200201N001512200059N016093199+00121-00641999999ADDGD12991+0365819GE19AGL   +99999+99999GF104995999999036581999999MA1102031999999REMMET075METAR KEIK 010015Z AUTO 02003KT 10SM SCT120 01/M06 A3013 RMK AO2 T00121064=EQDD01      0ADE726\n0125720534001612024010100354+40017-105050FM-15+156499999V0209999C000012200019N016093199+00091-00641999999ADDGF100991999999999999999999MA1102071999999REMMET072METAR KEIK 010035Z AUTO 00000KT 10SM CLR 01/M06 A3014 RMK AO2 T00091064=\n0125720534001612024010100554+40017-105050FM-15+156499999V0209999C000012200019N016093199+00001-00701999999ADDGF100991999999999999999999MA1102071999999REMMET072METAR KEIK 010055Z AUTO 00000KT 10SM CLR 00/M07 A3014 RMK AO2 T00001070=\n0126720534001612024010101154+40017-105050FM-15+156499999V0209999C000012200019N016093199-00071-00711999999ADDGF100991999999999999999999MA1102101999999REMMET073METAR KEIK 010115Z AUTO 00000KT 10SM CLR M01/M07 A3015 RMK AO2 T10071071=\n0126720534001612024010101354+40017-105050FM-15+156499999V0209999C000012200019N016093199-00141-00711999999ADDGF100991999999999999999999MA1102101999999REMMET073METAR KEIK 010135Z AUTO 00000KT 10SM CLR M01/M07 A3015 RMK AO2 T10141071=\n</code></pre> <p>This is not very useful on its own. The  ISD Data Documentation defines the structure of each  line:</p> <ul> <li>Characters 5-10: the USAF ID</li> <li>Characters 11-15: the WBAN ID</li> <li>Characters 16-23: the date of the observation in the format YYYYMMDD</li> <li>Characters 24-27: the time of the observation (UTC) in the format HHMM</li> <li>and so on</li> </ul> <p>Looking at the first line in the sample, we see that the observation is from the station with USAF ID 720534, WBAN  ID 00161, and occurred on 2024-01-01 00:15 UTC.</p> <p>In addition to making stations easier to locate, the second advantage of <code>riweather</code> is that it parses these data  fields out of the text files and returns them in a labeled, easy-to-use format ready for further processing and  analysis.</p>"},{"location":"about/integrated_surface_dataset/#data-contents","title":"Data contents","text":"<p>According to the data documentation, every ISD observation contains three sections.</p>"},{"location":"about/integrated_surface_dataset/#control-data","title":"Control data","text":"<p>The first 60 characters of each record provide information about where the record came from. This includes</p> <ul> <li>Station identifiers (USAF and WBAN)</li> <li>Date and time of the observation</li> <li>An indicator for the source or combination of sources used in creating the observation</li> <li>Latitude and longitude of the station</li> <li>Type of observation, such as the National Solar Radiation Database or a METAR Aviation    routine weather report</li> <li>Elevation of the observation relative to Mean Sea Level, in meters</li> <li>Call letters assigned to the station</li> <li>Type of quality control process applied to the observation</li> </ul> <pre><code>&gt;&gt;&gt; from riweather import parser\n&gt;&gt;&gt; line = \"0184720534001612024010100154+40017-105050FM-15+156499999V0200201N001512200059N016093199+00121-00641999999\"\n&gt;&gt;&gt; record = parser.parse_line(line)\n&gt;&gt;&gt; record.control\nControlData(total_variable_characters=184, usaf_id='720534', wban_id='00161', dt=datetime.datetime(2024, 1, 1, 0, 15, tzinfo=datetime.timezone.utc), data_source_flag='4', latitude=40.017, longitude=-105.05, report_type_code='FM-15', elevation=1564, call_letter_id=None, qc_process_name='V020')\n</code></pre>"},{"location":"about/integrated_surface_dataset/#mandatory-data","title":"Mandatory data","text":"<p>The next 45 characters of each record contain basic meteorological information that is present in most observations.  This includes</p> <ul> <li>Wind direction (degree angle relative to true north)</li> <li>Wind observation type, such as \u201ccalm\u201d, \u201cnormal\u201d, or \u201cvariable\u201d</li> <li>Wind speed (meters per second)</li> <li>Sky ceiling height, the height above ground level of the lowest cloud cover, in meters</li> <li>A code representing the method of determining the ceiling, such as \u201cestimated\u201d, \u201cmeasured\u201d, or \u201caircraft\u201d</li> <li>Visibility distance, in meters</li> <li>Air temperature, in degrees Celsius</li> <li>Dew point temperature, in degrees Celsius</li> <li>Sea level pressure, in hectopascals (hPa)</li> </ul> <pre><code>&gt;&gt;&gt; from riweather import parser\n&gt;&gt;&gt; line = \"0184720534001612024010100154+40017-105050FM-15+156499999V0200201N001512200059N016093199+00121-00641999999\"\n&gt;&gt;&gt; record = parser.parse_line(line)\n&gt;&gt;&gt; record.mandatory\nMandatoryData(\n    wind=WindObservation(\n        direction_angle=20, \n        direction_quality_code='1', \n        type_code='N', \n        speed_rate=1.5, \n        speed_quality_code='1',\n    ), \n    ceiling=SkyConditionObservation(\n        ceiling_height=22000, \n        ceiling_quality_code='5', \n        ceiling_determination_code=None, \n        cavok_code='N',\n    ), \n    visibility=VisibilityObservation(\n        distance=16093, \n        distance_quality_code='1', \n        variability_code=None, \n        variability_quality_code='9',\n    ), \n    air_temperature=AirTemperatureObservation(\n        temperature_c=1.2,\n        quality_code='1', \n        temperature_f=34.16,\n    ), \n    dew_point=AirTemperatureObservation(\n        temperature_c=-6.4, \n        quality_code='1', \n        temperature_f=20.48,\n    ), \n    sea_level_pressure=AtmosphericPressureObservation(\n        pressure=None, \n        quality_code='9',\n    ),\n)\n</code></pre>"},{"location":"about/integrated_surface_dataset/#additional-data","title":"Additional data","text":"<p>The remaining characters of each record contain \u201cadditional data\u201d. This is data of variable length that may or may  not be present and/or is recorded with varying degrees of frequency at the station.</p> <p>Note</p> <p>Currently, <code>riweather</code> only parses the control and mandatory data sections. Support for the additional data  section is considered a future enhancement.</p>"},{"location":"about/shorthand_codes/","title":"Shorthand codes","text":"<p>Note</p> <p>For the \u201cquality code\u201d fields in each data element, the following may appear in data which were processed through  NCEI\u2019s Interactive QC system (manual interaction), for selected parameters:</p> Value Description <code>A</code> Data value flagged as suspect, but accepted as good value. <code>U</code> Data value replaced with edited value. <code>P</code> Data value not originally flagged as suspect, but replaced by validator. <code>I</code> Data value not originally in data, but inserted by validator. <code>M</code> Manual change made to value based on information provided by NWS or FAA <code>C</code> Temperature and dew point received from Automated Weather Observing Systems (AWOS) are reported in whole degrees Celsius. Automated QC flags these values, but they are accepted as valid. <code>R</code> Data value replaced with value computed by NCEI software."},{"location":"about/shorthand_codes/#quality-codes","title":"Quality codes","text":"Value Description <code>0</code> Passed gross limits check <code>1</code> Passed all quality control checks <code>2</code> Suspect <code>3</code> Erroneous <code>4</code> Passed gross limits check, data originate from an NCEI data source <code>5</code> Passed all quality control checks, data originate from an NCEI data source <code>6</code> Suspect, data originate from an NCEI data source <code>7</code> Erroneous, data originate from an NCEI data source <code>9</code> Passed gross limits check if element is present"},{"location":"about/shorthand_codes/#controldatadata_source_flag","title":"<code>ControlData.data_source_flag</code>","text":"Value Description <code>1</code> USAF SURFACE HOURLY observation, candidate for merge with NCEI SURFACE HOURLY (not yet merged, failed element cross-checks) <code>2</code> NCEI SURFACE HOURLY observation, candidate for merge with USAF SURFACE HOURLY (not yet merged, failed element cross-checks) <code>3</code> USAF SURFACE HOURLY/NCEI SURFACE HOURLY merged observation <code>4</code> USAF SURFACE HOURLY observation <code>5</code> NCEI SURFACE HOURLY observation <code>6</code> ASOS/AWOS observation from NCEI <code>7</code> ASOS/AWOS observation merged with USAF SURFACE HOURLY observation <code>8</code> MAPSO observation (NCEI) <code>A</code> USAF SURFACE HOURLY/NCEI HOURLY PRECIPITATION merged observation, candidate for merge with NCEI SURFACE HOURLY (not yet merged, failed element cross-checks) <code>B</code> NCEI SURFACE HOURLY/NCEI HOURLY PRECIPITATION merged observation, candidate for merge with USAF SURFACE HOURLY (not yet merged, failed element cross-checks) <code>C</code> USAF SURFACE HOURLY/NCEI SURFACE HOURLY/NCEI HOURLY PRECIPITATION merged observation <code>D</code> USAF SURFACE HOURLY/NCEI HOURLY PRECIPITATION merged observation <code>E</code> NCEI SURFACE HOURLY/NCEI HOURLY PRECIPITATION merged observation <code>F</code> Form OMR/1001 \u2013 Weather Bureau city office (keyed data) <code>G</code> SAO surface airways observation, pre-1949 (keyed data) <code>H</code> SAO surface airways observation, 1965-1981 format/period (keyed data) <code>I</code> Climate Reference Network observation <code>J</code> Cooperative Network observation <code>K</code> Radiation Network observation <code>L</code> Data from Climate Data Modernization Program (CDMP) data source <code>M</code> Data from National Renewable Energy Laboratory (NREL) data source <code>N</code> NCAR / NCEI cooperative effort (various national datasets) <code>O</code> Summary observation created by NCEI using hourly observations that may not share the same data source flag. <code>9</code> Missing"},{"location":"about/shorthand_codes/#controldatareport_type_code","title":"<code>ControlData.report_type_code</code>","text":"Value Description <code>AERO</code> Aerological report <code>AUST</code> Dataset from Australia <code>AUTO</code> Report from an automatic station <code>BOGUS</code> Bogus report <code>BRAZ</code> Dataset from Brazil <code>COOPD</code> US Cooperative Network summary of day report <code>COOPS</code> US Cooperative Network soil temperature report <code>CRB</code> Climate Reference Book data from CDMP <code>CRN05</code> Climate Reference Network report, with 5-minute reporting interval <code>CRN15</code> Climate Reference Network report, with 15-minute reporting interval <code>FM-12</code> SYNOP Report of surface observation form a fixed land station <code>FM-13</code> SHIP Report of surface observation from a sea station <code>FM-14</code> SYNOP MOBIL Report of surface observation from a mobile land station <code>FM-15</code> METAR Aviation routine weather report <code>FM-16</code> SPECI Aviation selected special weather report <code>FM-18</code> BUOY Report of a buoy observation <code>GREEN</code> Dataset from Greenland <code>MESOH</code> Hydrological observations from MESONET operated civilian or government agency <code>MESOS</code> MESONET operated civilian or government agency <code>MESOW</code> Snow observations from MESONET operated civilian or government agency <code>MEXIC</code> Dataset from Mexico <code>NSRDB</code> National Solar Radiation Data Base <code>PCP15</code> US 15-minute precipitation network report <code>PCP60</code> US 60-minute precipitation network report <code>S-S-A</code> Synoptic, airways, and auto merged report <code>SA-AU</code> Airways and auto merged report <code>SAO</code> Airways report (includes record specials) <code>SAOSP</code> Airways special report (excluding record specials) <code>SHEF</code> Standard Hydrologic Exchange Format <code>SMARS</code> Supplementary airways station report <code>SOD</code> Summary of day report from U.S. ASOS or AWOS station <code>SOM</code> Summary of month report from U.S. ASOS or AWOS station <code>SURF</code> Surface Radiation Network report <code>SY-AE</code> Synoptic and aero merged report <code>SY-AU</code> Synoptic and auto merged report <code>SY-MT</code> Synoptic and METAR merged report <code>SY-SA</code> Synoptic and airways merged report <code>WBO</code> Weather Bureau Office <code>WNO</code> Washington Naval Observatory <code>99999</code> Missing"},{"location":"about/shorthand_codes/#controldataqc_process_name","title":"<code>ControlData.qc_process_name</code>","text":"Value Description <code>V010</code> No A or M Quality Control applied <code>V020</code> Automated Quality Control <code>V030</code> Subjected to Quality Control"},{"location":"about/shorthand_codes/#windobservationtype_code","title":"<code>WindObservation.type_code</code>","text":"Value Description <code>A</code> Abridged Beaufort <code>B</code> Beaufort <code>C</code> Calm <code>H</code> 5-Minute Average Speed <code>N</code> Normal <code>R</code> 60-Minute Average Speed <code>Q</code> Squall <code>T</code> 180 Minute Average Speed <code>V</code> Variable <code>9</code> Missing <p>Note</p> <p>If a value of 9 appears with a wind speed of <code>0000</code>, this  indicates calm winds.</p>"},{"location":"about/shorthand_codes/#skyconditionobservationceiling_determination_code","title":"<code>SkyConditionObservation.ceiling_determination_code</code>","text":"Value Description <code>A</code> Aircraft <code>B</code> Balloon <code>C</code> Statistically derived <code>D</code> Persistent cirriform ceiling (pre-1950 data) <code>E</code> Estimated <code>M</code> Measured <code>P</code> Precipitation ceiling (pre-1950 data) <code>R</code> Radar <code>S</code> ASOS augmented <code>U</code> Unknown ceiling (pre-1950 data) <code>V</code> Variable ceiling (pre-1950 data) <code>W</code> Obscured <code>9</code> Missing"},{"location":"about/shorthand_codes/#airtemperatureobservationquality_code","title":"<code>AirTemperatureObservation.quality_code</code>","text":"Value Description <code>0</code> Passed gross limits check <code>1</code> Passed all quality control checks <code>2</code> Suspect <code>3</code> Erroneous <code>4</code> Passed gross limits check, data originate from an NCEI data source <code>5</code> Passed all quality control checks, data originate from an NCEI data source <code>6</code> Suspect, data originate from an NCEI data source <code>7</code> Erroneous, data originate from an NCEI data source <code>9</code> Passed gross limits check if element is present <code>A</code> Data value flagged as suspect, but accepted as a good value <code>C</code> Temperature and dew point received from Automated Weather Observing System (AWOS) are reported in whole degrees Celsius. Automated QC flags these values, but they are accepted as valid. <code>I</code> Data value not originally in data, but inserted by validator <code>M</code> Manual changes made to value based on information provided by NWS or FAA <code>P</code> Data value not originally flagged as suspect, but replaced by validator <code>R</code> Data value replaced with value computed by NCEI software <code>U</code> Data value replaced with edited value"},{"location":"about/structure/","title":"Structure of <code>riweather</code> Data","text":"<p>The primary way to retrieve data using <code>riweather</code> is by using the <code>riweather.Station.fetch_data</code> function. It  returns data as a Pandas DataFrame for easy integration with other datasets and processing  pipelines.</p>"},{"location":"about/structure/#column-names-in-the-output","title":"Column names in the output","text":"<p>The columns of the retrieved data match the structure returned by  the <code>riweather</code> parser and also that which is laid out in the  ISD Data Documentation. Each column is named like</p> <pre><code>df[\"&lt;observation type&gt;.&lt;attribute name&gt;\"]\n</code></pre> <p>where <code>&lt;observation type&gt;</code> is one of the fields of the mandatory data section such as <code>wind</code>, <code>air_temperature</code>, or <code>dew_point</code>, and <code>&lt;attribute name&gt;</code> is one of the child attributes like <code>speed_rate</code> or <code>temperature_c</code>. So, if we fetch air temperature data from a station:</p> <pre><code>&gt;&gt;&gt; s = riweather.Station(\"720534\")\n&gt;&gt;&gt; df = s.fetch_data(2024, \"air_temperature\")\n</code></pre> <p>That DataFrame will contain three columns, one for each of the  attributes of <code>AirTemperatureObservation</code>.</p> <pre><code>&gt;&gt;&gt; df.columns.to_list()\n['air_temperature.temperature_c',\n 'air_temperature.quality_code',\n 'air_temperature.temperature_f']\n&gt;&gt;&gt; df[\"air_temperature.temperature_f\"]\n2024-01-01 00:15:00+00:00    34.16\n2024-01-01 00:35:00+00:00    33.62\n2024-01-01 00:55:00+00:00    32.00\n2024-01-01 01:15:00+00:00    30.74\n2024-01-01 01:35:00+00:00    29.48\nName: air_temperature.temperature_f, dtype: float64\n</code></pre> <p>The long column names are a lot of typing, but this was done to ensure there are no conflicts between similar types of  observations. For example, <code>'air_temperature'</code> and <code>'dew_point'</code> are both <code>AirTemperatureObservations</code>, so they both  have <code>temperature_c</code> as attributes.</p> <pre><code>&gt;&gt;&gt; df = s.fetch_data(2024, [\"dew_point\", \"air_temperature\"])\n&gt;&gt;&gt; df.columns.to_list()\n['air_temperature.temperature_c',\n 'air_temperature.quality_code',\n 'air_temperature.temperature_f',\n 'dew_point.temperature_c',\n 'dew_point.quality_code',\n 'dew_point.temperature_f']\n</code></pre> <p>We recommend renaming columns to something shorter once you have retrieved the data.</p> <pre><code>&gt;&gt;&gt; df = df.rename(columns={\"air_temperature.temperature_f\": \"tempF\", \n...                         \"dew_point.temperature_f\": \"dewF\"})\n&gt;&gt;&gt; df[[\"tempF\", \"dewF\"]].head()\n                           tempF   dewF\n2024-01-01 00:15:00+00:00  34.16  20.48\n2024-01-01 00:35:00+00:00  33.62  20.48\n2024-01-01 00:55:00+00:00  32.00  19.40\n2024-01-01 01:15:00+00:00  30.74  19.22\n2024-01-01 01:35:00+00:00  29.48  19.22\n</code></pre>"},{"location":"about/structure/#time-zones","title":"Time zones","text":"<p>Danger</p> <p>All timestamps are reported in UTC by default. If you are aligning weather data to another data set, make sure  you convert the weather data to the proper time zone first!</p> <p>Timestamps in the Integrated Surface Dataset are always stored in UTC. This is great news as consumers of the data,  because it eliminates any ambiguity around daylight savings conversions. However, it does mean that the weather  observations need to be converted to local time before they can be aligned with other datasets.</p> <p>You can do this very easily with Pandas after you have retrieved the data.</p> <pre><code>&gt;&gt;&gt; s = riweather.Station(\"720534\")\n&gt;&gt;&gt; df = s.fetch_data(2024, \"air_temperature\", temp_scale=\"F\", include_quality_codes=False)\n&gt;&gt;&gt; df.head()  # note the timestamps ending in +00:00, indicating UTC\n                           air_temperature.temperature_f\n2024-01-01 00:15:00+00:00                          34.16\n2024-01-01 00:35:00+00:00                          33.62\n2024-01-01 00:55:00+00:00                          32.00\n2024-01-01 01:15:00+00:00                          30.74\n2024-01-01 01:35:00+00:00                          29.48\n&gt;&gt;&gt; df = df.tz_convert(\"US/Mountain\")\n                           air_temperature.temperature_f\n2023-12-31 17:15:00-07:00                          34.16\n2023-12-31 17:35:00-07:00                          33.62\n2023-12-31 17:55:00-07:00                          32.00\n2023-12-31 18:15:00-07:00                          30.74\n2023-12-31 18:35:00-07:00                          29.48\n</code></pre> <p>Or, even easier, <code>riweather.Station.fetch_data</code> will do it for you if you pass the <code>tz</code> parameter.</p> <pre><code>&gt;&gt;&gt; s = riweather.Station(\"720534\")\n&gt;&gt;&gt; df = s.fetch_data(2024, \"air_temperature\", tz=\"US/Mountain\",\n...                   temp_scale=\"F\", include_quality_codes=False)\n                           air_temperature.temperature_f\n2023-12-31 17:15:00-07:00                          34.16\n2023-12-31 17:35:00-07:00                          33.62\n2023-12-31 17:55:00-07:00                          32.00\n2023-12-31 18:15:00-07:00                          30.74\n2023-12-31 18:35:00-07:00                          29.48\n</code></pre>"},{"location":"about/structure/#quality-codes","title":"Quality codes","text":"<p>ISD data has lots of shorthand codes indicating the source(s) of the weather observations, the method by which they  were collected, and the quality or reliability of the data. These codes make the data more complicated to look at  and increase the number of columns by quite a bit, but they can nevertheless be helpful when determining how  trustworthy the observations are. See the Shorthand Codes page for informative descriptions of  what these codes mean. </p> <p><code>riweather</code> returns these codes so that you can inspect them, but also provides some ways to suppress them from the  output if you\u2019d rather not clutter up the results. For example, specify <code>include_quality_codes=False</code> to prevent any  column ending in <code>quality_code</code> from ending up in the output. </p> <pre><code>&gt;&gt;&gt; s = riweather.Station(\"720534\")\n&gt;&gt;&gt; df = s.fetch_data(2024, \"air_temperature\")\n&gt;&gt;&gt; df.columns.to_list()\n['air_temperature.temperature_c',\n 'air_temperature.quality_code',\n 'air_temperature.temperature_f']\n&gt;&gt;&gt; df = s.fetch_data(2024, \"air_temperature\", include_quality_codes=False)\n&gt;&gt;&gt; df.columns.to_list()\n['air_temperature.temperature_c',\n 'air_temperature.temperature_f']\n</code></pre> <p>Of course, you could always drop the quality code columns yourself.</p> <pre><code>&gt;&gt;&gt; s = riweather.Station(\"720534\")\n&gt;&gt;&gt; df = s.fetch_data(2024, \"air_temperature\")\n&gt;&gt;&gt; df.columns.to_list()\n['air_temperature.temperature_c',\n 'air_temperature.quality_code',\n 'air_temperature.temperature_f']\n&gt;&gt;&gt; df = df.drop(columns=[\"air_temperature.quality_code\"])\n&gt;&gt;&gt; df.columns.to_list()\n['air_temperature.temperature_c',\n 'air_temperature.temperature_f']\n</code></pre>"},{"location":"api/parser/","title":"Parser","text":""},{"location":"api/parser/#riweather.parser.ISDRecord","title":"riweather.parser.ISDRecord  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>ISD data record.</p> Show JSON schema: <pre><code>{\n  \"$defs\": {\n    \"AdditionalData\": {\n      \"description\": \"Additional data section.\\n\\n!!! warning\\n    Not yet implemented. Reserved for future use.\",\n      \"properties\": {},\n      \"title\": \"AdditionalData\",\n      \"type\": \"object\"\n    },\n    \"AirTemperatureObservation\": {\n      \"description\": \"An observation of current air temperature.\",\n      \"properties\": {\n        \"temperature_c\": {\n          \"anyOf\": [\n            {\n              \"type\": \"number\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Temperature C\"\n        },\n        \"quality_code\": {\n          \"maxLength\": 1,\n          \"title\": \"Quality Code\",\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"temperature_c\",\n        \"quality_code\"\n      ],\n      \"title\": \"AirTemperatureObservation\",\n      \"type\": \"object\"\n    },\n    \"AtmosphericPressureObservation\": {\n      \"description\": \"An observation of current atmospheric pressure.\",\n      \"properties\": {\n        \"pressure\": {\n          \"anyOf\": [\n            {\n              \"type\": \"number\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Pressure\"\n        },\n        \"quality_code\": {\n          \"maxLength\": 1,\n          \"title\": \"Quality Code\",\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"pressure\",\n        \"quality_code\"\n      ],\n      \"title\": \"AtmosphericPressureObservation\",\n      \"type\": \"object\"\n    },\n    \"ControlData\": {\n      \"description\": \"Control data section.\\n\\n!!! usage\\n    [Control Data](../about/integrated_surface_dataset.md#control-data)\",\n      \"properties\": {\n        \"total_variable_characters\": {\n          \"title\": \"Total Variable Characters\",\n          \"type\": \"integer\"\n        },\n        \"usaf_id\": {\n          \"maxLength\": 6,\n          \"minLength\": 6,\n          \"pattern\": \"^\\\\w*$\",\n          \"title\": \"Usaf Id\",\n          \"type\": \"string\"\n        },\n        \"wban_id\": {\n          \"maxLength\": 5,\n          \"minLength\": 5,\n          \"pattern\": \"^\\\\d*$\",\n          \"title\": \"Wban Id\",\n          \"type\": \"string\"\n        },\n        \"dt\": {\n          \"format\": \"date-time\",\n          \"title\": \"Dt\",\n          \"type\": \"string\"\n        },\n        \"data_source_flag\": {\n          \"anyOf\": [\n            {\n              \"maxLength\": 1,\n              \"type\": \"string\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Data Source Flag\"\n        },\n        \"latitude\": {\n          \"anyOf\": [\n            {\n              \"type\": \"number\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Latitude\"\n        },\n        \"longitude\": {\n          \"anyOf\": [\n            {\n              \"type\": \"number\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Longitude\"\n        },\n        \"report_type_code\": {\n          \"anyOf\": [\n            {\n              \"maxLength\": 5,\n              \"type\": \"string\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Report Type Code\"\n        },\n        \"elevation\": {\n          \"anyOf\": [\n            {\n              \"type\": \"integer\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Elevation\"\n        },\n        \"call_letter_id\": {\n          \"anyOf\": [\n            {\n              \"maxLength\": 5,\n              \"type\": \"string\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Call Letter Id\"\n        },\n        \"qc_process_name\": {\n          \"maxLength\": 4,\n          \"title\": \"Qc Process Name\",\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"total_variable_characters\",\n        \"usaf_id\",\n        \"wban_id\",\n        \"dt\",\n        \"data_source_flag\",\n        \"latitude\",\n        \"longitude\",\n        \"report_type_code\",\n        \"elevation\",\n        \"call_letter_id\",\n        \"qc_process_name\"\n      ],\n      \"title\": \"ControlData\",\n      \"type\": \"object\"\n    },\n    \"MandatoryData\": {\n      \"description\": \"Mandatory data section.\",\n      \"properties\": {\n        \"wind\": {\n          \"$ref\": \"#/$defs/WindObservation\"\n        },\n        \"ceiling\": {\n          \"$ref\": \"#/$defs/SkyConditionObservation\"\n        },\n        \"visibility\": {\n          \"$ref\": \"#/$defs/VisibilityObservation\"\n        },\n        \"air_temperature\": {\n          \"$ref\": \"#/$defs/AirTemperatureObservation\"\n        },\n        \"dew_point\": {\n          \"$ref\": \"#/$defs/AirTemperatureObservation\"\n        },\n        \"sea_level_pressure\": {\n          \"$ref\": \"#/$defs/AtmosphericPressureObservation\"\n        }\n      },\n      \"required\": [\n        \"wind\",\n        \"ceiling\",\n        \"visibility\",\n        \"air_temperature\",\n        \"dew_point\",\n        \"sea_level_pressure\"\n      ],\n      \"title\": \"MandatoryData\",\n      \"type\": \"object\"\n    },\n    \"SkyConditionObservation\": {\n      \"description\": \"An observation of current sky condition.\",\n      \"properties\": {\n        \"ceiling_height\": {\n          \"anyOf\": [\n            {\n              \"type\": \"integer\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Ceiling Height\"\n        },\n        \"ceiling_quality_code\": {\n          \"maxLength\": 1,\n          \"title\": \"Ceiling Quality Code\",\n          \"type\": \"string\"\n        },\n        \"ceiling_determination_code\": {\n          \"anyOf\": [\n            {\n              \"maxLength\": 1,\n              \"type\": \"string\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Ceiling Determination Code\"\n        },\n        \"cavok_code\": {\n          \"anyOf\": [\n            {\n              \"maxLength\": 1,\n              \"type\": \"string\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Cavok Code\"\n        }\n      },\n      \"required\": [\n        \"ceiling_height\",\n        \"ceiling_quality_code\",\n        \"ceiling_determination_code\",\n        \"cavok_code\"\n      ],\n      \"title\": \"SkyConditionObservation\",\n      \"type\": \"object\"\n    },\n    \"VisibilityObservation\": {\n      \"description\": \"An observation of current sky visibility.\",\n      \"properties\": {\n        \"distance\": {\n          \"anyOf\": [\n            {\n              \"type\": \"integer\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Distance\"\n        },\n        \"distance_quality_code\": {\n          \"maxLength\": 1,\n          \"title\": \"Distance Quality Code\",\n          \"type\": \"string\"\n        },\n        \"variability_code\": {\n          \"anyOf\": [\n            {\n              \"maxLength\": 1,\n              \"type\": \"string\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Variability Code\"\n        },\n        \"variability_quality_code\": {\n          \"maxLength\": 1,\n          \"title\": \"Variability Quality Code\",\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"distance\",\n        \"distance_quality_code\",\n        \"variability_code\",\n        \"variability_quality_code\"\n      ],\n      \"title\": \"VisibilityObservation\",\n      \"type\": \"object\"\n    },\n    \"WindObservation\": {\n      \"description\": \"An observation of current wind speed and direction.\",\n      \"properties\": {\n        \"direction_angle\": {\n          \"anyOf\": [\n            {\n              \"type\": \"integer\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Direction Angle\"\n        },\n        \"direction_quality_code\": {\n          \"maxLength\": 1,\n          \"title\": \"Direction Quality Code\",\n          \"type\": \"string\"\n        },\n        \"type_code\": {\n          \"anyOf\": [\n            {\n              \"maxLength\": 1,\n              \"type\": \"string\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Type Code\"\n        },\n        \"speed_rate\": {\n          \"anyOf\": [\n            {\n              \"type\": \"number\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Speed Rate\"\n        },\n        \"speed_quality_code\": {\n          \"maxLength\": 1,\n          \"title\": \"Speed Quality Code\",\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"direction_angle\",\n        \"direction_quality_code\",\n        \"type_code\",\n        \"speed_rate\",\n        \"speed_quality_code\"\n      ],\n      \"title\": \"WindObservation\",\n      \"type\": \"object\"\n    }\n  },\n  \"description\": \"ISD data record.\",\n  \"properties\": {\n    \"control\": {\n      \"$ref\": \"#/$defs/ControlData\"\n    },\n    \"mandatory\": {\n      \"$ref\": \"#/$defs/MandatoryData\"\n    },\n    \"additional\": {\n      \"items\": {\n        \"$ref\": \"#/$defs/AdditionalData\"\n      },\n      \"title\": \"Additional\",\n      \"type\": \"array\"\n    }\n  },\n  \"required\": [\n    \"control\",\n    \"mandatory\"\n  ],\n  \"title\": \"ISDRecord\",\n  \"type\": \"object\"\n}\n</code></pre> <p>Fields:</p> <ul> <li> <code>control</code>                 (<code>ControlData</code>)             </li> <li> <code>mandatory</code>                 (<code>MandatoryData</code>)             </li> <li> <code>additional</code>                 (<code>list[AdditionalData]</code>)             </li> </ul>"},{"location":"api/parser/#riweather.parser.ControlData","title":"riweather.parser.ControlData  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Control data section.</p> <p>Usage</p> <p>Control Data</p> Show JSON schema: <pre><code>{\n  \"description\": \"Control data section.\\n\\n!!! usage\\n    [Control Data](../about/integrated_surface_dataset.md#control-data)\",\n  \"properties\": {\n    \"total_variable_characters\": {\n      \"title\": \"Total Variable Characters\",\n      \"type\": \"integer\"\n    },\n    \"usaf_id\": {\n      \"maxLength\": 6,\n      \"minLength\": 6,\n      \"pattern\": \"^\\\\w*$\",\n      \"title\": \"Usaf Id\",\n      \"type\": \"string\"\n    },\n    \"wban_id\": {\n      \"maxLength\": 5,\n      \"minLength\": 5,\n      \"pattern\": \"^\\\\d*$\",\n      \"title\": \"Wban Id\",\n      \"type\": \"string\"\n    },\n    \"dt\": {\n      \"format\": \"date-time\",\n      \"title\": \"Dt\",\n      \"type\": \"string\"\n    },\n    \"data_source_flag\": {\n      \"anyOf\": [\n        {\n          \"maxLength\": 1,\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"title\": \"Data Source Flag\"\n    },\n    \"latitude\": {\n      \"anyOf\": [\n        {\n          \"type\": \"number\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"title\": \"Latitude\"\n    },\n    \"longitude\": {\n      \"anyOf\": [\n        {\n          \"type\": \"number\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"title\": \"Longitude\"\n    },\n    \"report_type_code\": {\n      \"anyOf\": [\n        {\n          \"maxLength\": 5,\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"title\": \"Report Type Code\"\n    },\n    \"elevation\": {\n      \"anyOf\": [\n        {\n          \"type\": \"integer\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"title\": \"Elevation\"\n    },\n    \"call_letter_id\": {\n      \"anyOf\": [\n        {\n          \"maxLength\": 5,\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"title\": \"Call Letter Id\"\n    },\n    \"qc_process_name\": {\n      \"maxLength\": 4,\n      \"title\": \"Qc Process Name\",\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\n    \"total_variable_characters\",\n    \"usaf_id\",\n    \"wban_id\",\n    \"dt\",\n    \"data_source_flag\",\n    \"latitude\",\n    \"longitude\",\n    \"report_type_code\",\n    \"elevation\",\n    \"call_letter_id\",\n    \"qc_process_name\"\n  ],\n  \"title\": \"ControlData\",\n  \"type\": \"object\"\n}\n</code></pre> <p>Fields:</p> <ul> <li> <code>total_variable_characters</code>                 (<code>int</code>)             </li> <li> <code>usaf_id</code>                 (<code>str</code>)             </li> <li> <code>wban_id</code>                 (<code>str</code>)             </li> <li> <code>dt</code>                 (<code>datetime</code>)             </li> <li> <code>data_source_flag</code>                 (<code>str | None</code>)             </li> <li> <code>latitude</code>                 (<code>float | None</code>)             </li> <li> <code>longitude</code>                 (<code>float | None</code>)             </li> <li> <code>report_type_code</code>                 (<code>str | None</code>)             </li> <li> <code>elevation</code>                 (<code>int | None</code>)             </li> <li> <code>call_letter_id</code>                 (<code>str | None</code>)             </li> <li> <code>qc_process_name</code>                 (<code>str</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>parse_datetime</code>                 \u2192                   <code>dt</code> </li> </ul>"},{"location":"api/parser/#riweather.parser.ControlData.total_variable_characters","title":"total_variable_characters  <code>pydantic-field</code>","text":"<pre><code>total_variable_characters\n</code></pre> <p>Total number of characters in the variable length section. The total record length equals 105 plus the value stored in this field.</p>"},{"location":"api/parser/#riweather.parser.ControlData.usaf_id","title":"usaf_id  <code>pydantic-field</code>","text":"<pre><code>usaf_id\n</code></pre> <p>United States Air Force (USAF) Master Station Catalog identifier. For United States stations, this is a value between 720000 and 799999.</p>"},{"location":"api/parser/#riweather.parser.ControlData.wban_id","title":"wban_id  <code>pydantic-field</code>","text":"<pre><code>wban_id\n</code></pre> <p>NCEI Weather Bureau Army-Navy (WBAN) identifier.</p>"},{"location":"api/parser/#riweather.parser.ControlData.dt","title":"dt  <code>pydantic-field</code>","text":"<pre><code>dt\n</code></pre> <p>The date and time of the observation, based on Coordinated Universal Time (UTC).</p>"},{"location":"api/parser/#riweather.parser.ControlData.data_source_flag","title":"data_source_flag  <code>pydantic-field</code>","text":"<pre><code>data_source_flag\n</code></pre> <p>A flag indicating the source or combination of sources used in creating the observation.</p> <p>Note</p> <p>Possible values</p>"},{"location":"api/parser/#riweather.parser.ControlData.latitude","title":"latitude  <code>pydantic-field</code>","text":"<pre><code>latitude\n</code></pre> <p>The latitude coordinate of the observation. Negative values are located in the southern hemisphere.</p>"},{"location":"api/parser/#riweather.parser.ControlData.longitude","title":"longitude  <code>pydantic-field</code>","text":"<pre><code>longitude\n</code></pre> <p>The longitude coordinate of the observation. Negative values are located in the western hemisphere.</p>"},{"location":"api/parser/#riweather.parser.ControlData.report_type_code","title":"report_type_code  <code>pydantic-field</code>","text":"<pre><code>report_type_code\n</code></pre> <p>A flag indicating the type of geophysical surface observation.</p> <p>Note</p> <p>Possible values</p>"},{"location":"api/parser/#riweather.parser.ControlData.elevation","title":"elevation  <code>pydantic-field</code>","text":"<pre><code>elevation\n</code></pre> <p>The elevation of the observation relative to Mean Sea Level, in meters.</p>"},{"location":"api/parser/#riweather.parser.ControlData.call_letter_id","title":"call_letter_id  <code>pydantic-field</code>","text":"<pre><code>call_letter_id\n</code></pre> <p>The call letters associated with the station.</p>"},{"location":"api/parser/#riweather.parser.ControlData.qc_process_name","title":"qc_process_name  <code>pydantic-field</code>","text":"<pre><code>qc_process_name\n</code></pre> <p>Quality control process applied to the observation.</p> <p>Note</p> <p>Possible values</p>"},{"location":"api/parser/#riweather.parser.ControlData.parse_datetime","title":"parse_datetime  <code>pydantic-validator</code>","text":"<pre><code>parse_datetime(value)\n</code></pre> <p>Parse dates and times as they appear in ISD to a tz-aware datetime object.</p> <p>This is a Pydantic validator, users shouldn\u2019t need to call this directly (though they can).</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>Any</code>)           \u2013            <p>The portion of the record in the data file corresponding to the date and time fields, characters 16-27. This is always in the form <code>YYYYMMDDHHMM</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>datetime</code>           \u2013            <p>A timezone-aware datetime object representing the date and time, set to UTC.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ControlData.parse_datetime(\"201809220115\")\ndatetime.datetime(2018, 9, 22, 1, 15, tzinfo=datetime.timezone.utc)\n</code></pre> <pre><code>&gt;&gt;&gt; ControlData.parse_datetime(\"201809310115\")\nTraceback (most recent call last):\nValueError: day is out of range for month\n</code></pre> Source code in <code>src/riweather/parser.py</code> <pre><code>@field_validator(\"dt\", mode=\"before\")\n@classmethod\ndef parse_datetime(cls, value: Any) -&gt; datetime:\n    \"\"\"Parse dates and times as they appear in ISD to a tz-aware datetime object.\n\n    This is a [Pydantic validator](https://docs.pydantic.dev/latest/concepts/validators/), users\n    shouldn't need to call this directly (though they can).\n\n    Args:\n        value: The portion of the record in the data file corresponding to the date and\n            time fields, characters 16-27. This is always in the form `YYYYMMDDHHMM`.\n\n    Returns:\n        A timezone-aware datetime object representing the date and time, set to UTC.\n\n    Examples:\n        &gt;&gt;&gt; ControlData.parse_datetime(\"201809220115\")\n        datetime.datetime(2018, 9, 22, 1, 15, tzinfo=datetime.timezone.utc)\n\n        &gt;&gt;&gt; ControlData.parse_datetime(\"201809310115\")\n        Traceback (most recent call last):\n        ValueError: day is out of range for month\n    \"\"\"\n    return datetime.strptime(value, \"%Y%m%d%H%M\").replace(tzinfo=timezone.utc)\n</code></pre>"},{"location":"api/parser/#riweather.parser.MandatoryData","title":"riweather.parser.MandatoryData  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mandatory data section.</p> Show JSON schema: <pre><code>{\n  \"$defs\": {\n    \"AirTemperatureObservation\": {\n      \"description\": \"An observation of current air temperature.\",\n      \"properties\": {\n        \"temperature_c\": {\n          \"anyOf\": [\n            {\n              \"type\": \"number\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Temperature C\"\n        },\n        \"quality_code\": {\n          \"maxLength\": 1,\n          \"title\": \"Quality Code\",\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"temperature_c\",\n        \"quality_code\"\n      ],\n      \"title\": \"AirTemperatureObservation\",\n      \"type\": \"object\"\n    },\n    \"AtmosphericPressureObservation\": {\n      \"description\": \"An observation of current atmospheric pressure.\",\n      \"properties\": {\n        \"pressure\": {\n          \"anyOf\": [\n            {\n              \"type\": \"number\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Pressure\"\n        },\n        \"quality_code\": {\n          \"maxLength\": 1,\n          \"title\": \"Quality Code\",\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"pressure\",\n        \"quality_code\"\n      ],\n      \"title\": \"AtmosphericPressureObservation\",\n      \"type\": \"object\"\n    },\n    \"SkyConditionObservation\": {\n      \"description\": \"An observation of current sky condition.\",\n      \"properties\": {\n        \"ceiling_height\": {\n          \"anyOf\": [\n            {\n              \"type\": \"integer\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Ceiling Height\"\n        },\n        \"ceiling_quality_code\": {\n          \"maxLength\": 1,\n          \"title\": \"Ceiling Quality Code\",\n          \"type\": \"string\"\n        },\n        \"ceiling_determination_code\": {\n          \"anyOf\": [\n            {\n              \"maxLength\": 1,\n              \"type\": \"string\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Ceiling Determination Code\"\n        },\n        \"cavok_code\": {\n          \"anyOf\": [\n            {\n              \"maxLength\": 1,\n              \"type\": \"string\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Cavok Code\"\n        }\n      },\n      \"required\": [\n        \"ceiling_height\",\n        \"ceiling_quality_code\",\n        \"ceiling_determination_code\",\n        \"cavok_code\"\n      ],\n      \"title\": \"SkyConditionObservation\",\n      \"type\": \"object\"\n    },\n    \"VisibilityObservation\": {\n      \"description\": \"An observation of current sky visibility.\",\n      \"properties\": {\n        \"distance\": {\n          \"anyOf\": [\n            {\n              \"type\": \"integer\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Distance\"\n        },\n        \"distance_quality_code\": {\n          \"maxLength\": 1,\n          \"title\": \"Distance Quality Code\",\n          \"type\": \"string\"\n        },\n        \"variability_code\": {\n          \"anyOf\": [\n            {\n              \"maxLength\": 1,\n              \"type\": \"string\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Variability Code\"\n        },\n        \"variability_quality_code\": {\n          \"maxLength\": 1,\n          \"title\": \"Variability Quality Code\",\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"distance\",\n        \"distance_quality_code\",\n        \"variability_code\",\n        \"variability_quality_code\"\n      ],\n      \"title\": \"VisibilityObservation\",\n      \"type\": \"object\"\n    },\n    \"WindObservation\": {\n      \"description\": \"An observation of current wind speed and direction.\",\n      \"properties\": {\n        \"direction_angle\": {\n          \"anyOf\": [\n            {\n              \"type\": \"integer\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Direction Angle\"\n        },\n        \"direction_quality_code\": {\n          \"maxLength\": 1,\n          \"title\": \"Direction Quality Code\",\n          \"type\": \"string\"\n        },\n        \"type_code\": {\n          \"anyOf\": [\n            {\n              \"maxLength\": 1,\n              \"type\": \"string\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Type Code\"\n        },\n        \"speed_rate\": {\n          \"anyOf\": [\n            {\n              \"type\": \"number\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"title\": \"Speed Rate\"\n        },\n        \"speed_quality_code\": {\n          \"maxLength\": 1,\n          \"title\": \"Speed Quality Code\",\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"direction_angle\",\n        \"direction_quality_code\",\n        \"type_code\",\n        \"speed_rate\",\n        \"speed_quality_code\"\n      ],\n      \"title\": \"WindObservation\",\n      \"type\": \"object\"\n    }\n  },\n  \"description\": \"Mandatory data section.\",\n  \"properties\": {\n    \"wind\": {\n      \"$ref\": \"#/$defs/WindObservation\"\n    },\n    \"ceiling\": {\n      \"$ref\": \"#/$defs/SkyConditionObservation\"\n    },\n    \"visibility\": {\n      \"$ref\": \"#/$defs/VisibilityObservation\"\n    },\n    \"air_temperature\": {\n      \"$ref\": \"#/$defs/AirTemperatureObservation\"\n    },\n    \"dew_point\": {\n      \"$ref\": \"#/$defs/AirTemperatureObservation\"\n    },\n    \"sea_level_pressure\": {\n      \"$ref\": \"#/$defs/AtmosphericPressureObservation\"\n    }\n  },\n  \"required\": [\n    \"wind\",\n    \"ceiling\",\n    \"visibility\",\n    \"air_temperature\",\n    \"dew_point\",\n    \"sea_level_pressure\"\n  ],\n  \"title\": \"MandatoryData\",\n  \"type\": \"object\"\n}\n</code></pre> <p>Fields:</p> <ul> <li> <code>wind</code>                 (<code>WindObservation</code>)             </li> <li> <code>ceiling</code>                 (<code>SkyConditionObservation</code>)             </li> <li> <code>visibility</code>                 (<code>VisibilityObservation</code>)             </li> <li> <code>air_temperature</code>                 (<code>AirTemperatureObservation</code>)             </li> <li> <code>dew_point</code>                 (<code>AirTemperatureObservation</code>)             </li> <li> <code>sea_level_pressure</code>                 (<code>AtmosphericPressureObservation</code>)             </li> </ul>"},{"location":"api/parser/#riweather.parser.AdditionalData","title":"riweather.parser.AdditionalData  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Additional data section.</p> <p>Warning</p> <p>Not yet implemented. Reserved for future use.</p> Show JSON schema: <pre><code>{\n  \"description\": \"Additional data section.\\n\\n!!! warning\\n    Not yet implemented. Reserved for future use.\",\n  \"properties\": {},\n  \"title\": \"AdditionalData\",\n  \"type\": \"object\"\n}\n</code></pre>"},{"location":"api/parser/#riweather.parser.WindObservation","title":"riweather.parser.WindObservation  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>An observation of current wind speed and direction.</p> Show JSON schema: <pre><code>{\n  \"description\": \"An observation of current wind speed and direction.\",\n  \"properties\": {\n    \"direction_angle\": {\n      \"anyOf\": [\n        {\n          \"type\": \"integer\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"title\": \"Direction Angle\"\n    },\n    \"direction_quality_code\": {\n      \"maxLength\": 1,\n      \"title\": \"Direction Quality Code\",\n      \"type\": \"string\"\n    },\n    \"type_code\": {\n      \"anyOf\": [\n        {\n          \"maxLength\": 1,\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"title\": \"Type Code\"\n    },\n    \"speed_rate\": {\n      \"anyOf\": [\n        {\n          \"type\": \"number\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"title\": \"Speed Rate\"\n    },\n    \"speed_quality_code\": {\n      \"maxLength\": 1,\n      \"title\": \"Speed Quality Code\",\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\n    \"direction_angle\",\n    \"direction_quality_code\",\n    \"type_code\",\n    \"speed_rate\",\n    \"speed_quality_code\"\n  ],\n  \"title\": \"WindObservation\",\n  \"type\": \"object\"\n}\n</code></pre> <p>Fields:</p> <ul> <li> <code>direction_angle</code>                 (<code>int | None</code>)             </li> <li> <code>direction_quality_code</code>                 (<code>str</code>)             </li> <li> <code>type_code</code>                 (<code>str | None</code>)             </li> <li> <code>speed_rate</code>                 (<code>float | None</code>)             </li> <li> <code>speed_quality_code</code>                 (<code>str</code>)             </li> </ul>"},{"location":"api/parser/#riweather.parser.WindObservation.direction_angle","title":"direction_angle  <code>pydantic-field</code>","text":"<pre><code>direction_angle\n</code></pre> <p>The angle, measured in angular degrees in a clockwise direction, between true north and the direction from which the wind is blowing.</p>"},{"location":"api/parser/#riweather.parser.WindObservation.direction_quality_code","title":"direction_quality_code  <code>pydantic-field</code>","text":"<pre><code>direction_quality_code\n</code></pre> <p>Quality status of the reported wind direction angle.</p> <p>Note</p> <p>Possible values</p>"},{"location":"api/parser/#riweather.parser.WindObservation.type_code","title":"type_code  <code>pydantic-field</code>","text":"<pre><code>type_code\n</code></pre> <p>Code that denotes the character of the wind observation.</p> <p>Note</p> <p>Possible values</p>"},{"location":"api/parser/#riweather.parser.WindObservation.speed_rate","title":"speed_rate  <code>pydantic-field</code>","text":"<pre><code>speed_rate\n</code></pre> <p>The rate of horizontal travel of air past a fixed point, in meters per second.</p>"},{"location":"api/parser/#riweather.parser.WindObservation.speed_quality_code","title":"speed_quality_code  <code>pydantic-field</code>","text":"<pre><code>speed_quality_code\n</code></pre> <p>Quality status of the reported wind speed rate.</p> <p>Note</p> <p>Possible values</p>"},{"location":"api/parser/#riweather.parser.SkyConditionObservation","title":"riweather.parser.SkyConditionObservation  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>An observation of current sky condition.</p> Show JSON schema: <pre><code>{\n  \"description\": \"An observation of current sky condition.\",\n  \"properties\": {\n    \"ceiling_height\": {\n      \"anyOf\": [\n        {\n          \"type\": \"integer\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"title\": \"Ceiling Height\"\n    },\n    \"ceiling_quality_code\": {\n      \"maxLength\": 1,\n      \"title\": \"Ceiling Quality Code\",\n      \"type\": \"string\"\n    },\n    \"ceiling_determination_code\": {\n      \"anyOf\": [\n        {\n          \"maxLength\": 1,\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"title\": \"Ceiling Determination Code\"\n    },\n    \"cavok_code\": {\n      \"anyOf\": [\n        {\n          \"maxLength\": 1,\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"title\": \"Cavok Code\"\n    }\n  },\n  \"required\": [\n    \"ceiling_height\",\n    \"ceiling_quality_code\",\n    \"ceiling_determination_code\",\n    \"cavok_code\"\n  ],\n  \"title\": \"SkyConditionObservation\",\n  \"type\": \"object\"\n}\n</code></pre> <p>Fields:</p> <ul> <li> <code>ceiling_height</code>                 (<code>int | None</code>)             </li> <li> <code>ceiling_quality_code</code>                 (<code>str</code>)             </li> <li> <code>ceiling_determination_code</code>                 (<code>str | None</code>)             </li> <li> <code>cavok_code</code>                 (<code>str | None</code>)             </li> </ul>"},{"location":"api/parser/#riweather.parser.SkyConditionObservation.ceiling_height","title":"ceiling_height  <code>pydantic-field</code>","text":"<pre><code>ceiling_height\n</code></pre> <p>The height above ground level (AGL) of the lowest cloud or obscuring phenomena layer aloft with 5/8 or more summation total sky cover, which may be predominantly opaque, or the vertical visibility into a surface-based obstruction.</p> <p>Note</p> <p>Unlimited ceiling height coded as <code>22000</code>.</p>"},{"location":"api/parser/#riweather.parser.SkyConditionObservation.ceiling_quality_code","title":"ceiling_quality_code  <code>pydantic-field</code>","text":"<pre><code>ceiling_quality_code\n</code></pre> <p>Quality status of the reported ceiling height.</p> <p>Note</p> <p>Possible values</p>"},{"location":"api/parser/#riweather.parser.SkyConditionObservation.ceiling_determination_code","title":"ceiling_determination_code  <code>pydantic-field</code>","text":"<pre><code>ceiling_determination_code\n</code></pre> <p>Code that denotes the method used to determine the ceiling.</p> <p>Note</p> <p>Possible values</p>"},{"location":"api/parser/#riweather.parser.SkyConditionObservation.cavok_code","title":"cavok_code  <code>pydantic-field</code>","text":"<pre><code>cavok_code\n</code></pre> <p>Code that represents whether the \u201cCeiling and Visibility Okay\u201d (CAVOK) condition has been reported.</p> Value Description <code>N</code> No <code>Y</code> Yes <code>9</code> Missing"},{"location":"api/parser/#riweather.parser.VisibilityObservation","title":"riweather.parser.VisibilityObservation  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>An observation of current sky visibility.</p> Show JSON schema: <pre><code>{\n  \"description\": \"An observation of current sky visibility.\",\n  \"properties\": {\n    \"distance\": {\n      \"anyOf\": [\n        {\n          \"type\": \"integer\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"title\": \"Distance\"\n    },\n    \"distance_quality_code\": {\n      \"maxLength\": 1,\n      \"title\": \"Distance Quality Code\",\n      \"type\": \"string\"\n    },\n    \"variability_code\": {\n      \"anyOf\": [\n        {\n          \"maxLength\": 1,\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"title\": \"Variability Code\"\n    },\n    \"variability_quality_code\": {\n      \"maxLength\": 1,\n      \"title\": \"Variability Quality Code\",\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\n    \"distance\",\n    \"distance_quality_code\",\n    \"variability_code\",\n    \"variability_quality_code\"\n  ],\n  \"title\": \"VisibilityObservation\",\n  \"type\": \"object\"\n}\n</code></pre> <p>Fields:</p> <ul> <li> <code>distance</code>                 (<code>int | None</code>)             </li> <li> <code>distance_quality_code</code>                 (<code>str</code>)             </li> <li> <code>variability_code</code>                 (<code>str | None</code>)             </li> <li> <code>variability_quality_code</code>                 (<code>str</code>)             </li> </ul>"},{"location":"api/parser/#riweather.parser.VisibilityObservation.distance","title":"distance  <code>pydantic-field</code>","text":"<pre><code>distance\n</code></pre> <p>The horizontal distance, in meters, at which an object can be seen and identified. Values greater than 160,000m are entered as <code>160000</code>.</p>"},{"location":"api/parser/#riweather.parser.VisibilityObservation.distance_quality_code","title":"distance_quality_code  <code>pydantic-field</code>","text":"<pre><code>distance_quality_code\n</code></pre> <p>Quality status of the reported visibility distance.</p> <p>Note</p> <p>Possible values</p>"},{"location":"api/parser/#riweather.parser.VisibilityObservation.variability_code","title":"variability_code  <code>pydantic-field</code>","text":"<pre><code>variability_code\n</code></pre> <p>Code that denotes whether or not the reported visibility is variable.</p> Value Description <code>N</code> Not variable <code>V</code> Variable <code>9</code> Missing"},{"location":"api/parser/#riweather.parser.VisibilityObservation.variability_quality_code","title":"variability_quality_code  <code>pydantic-field</code>","text":"<pre><code>variability_quality_code\n</code></pre> <p>Quality status of the reported variability code.</p> <p>Note</p> <p>Possible values</p>"},{"location":"api/parser/#riweather.parser.AirTemperatureObservation","title":"riweather.parser.AirTemperatureObservation  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>An observation of current air temperature.</p> Show JSON schema: <pre><code>{\n  \"description\": \"An observation of current air temperature.\",\n  \"properties\": {\n    \"temperature_c\": {\n      \"anyOf\": [\n        {\n          \"type\": \"number\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"title\": \"Temperature C\"\n    },\n    \"quality_code\": {\n      \"maxLength\": 1,\n      \"title\": \"Quality Code\",\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\n    \"temperature_c\",\n    \"quality_code\"\n  ],\n  \"title\": \"AirTemperatureObservation\",\n  \"type\": \"object\"\n}\n</code></pre> <p>Fields:</p> <ul> <li> <code>temperature_c</code>                 (<code>float | None</code>)             </li> <li> <code>quality_code</code>                 (<code>str</code>)             </li> </ul>"},{"location":"api/parser/#riweather.parser.AirTemperatureObservation.temperature_c","title":"temperature_c  <code>pydantic-field</code>","text":"<pre><code>temperature_c\n</code></pre> <p>Temperature in degrees Celsius.</p>"},{"location":"api/parser/#riweather.parser.AirTemperatureObservation.quality_code","title":"quality_code  <code>pydantic-field</code>","text":"<pre><code>quality_code\n</code></pre> <p>Quality status of the reported temperature.</p> <p>Note</p> <p>Possible values</p>"},{"location":"api/parser/#riweather.parser.AirTemperatureObservation.temperature_f","title":"temperature_f","text":"<pre><code>temperature_f()\n</code></pre> <p>The temperature of the air, in degrees Fahrenheit.</p> Source code in <code>src/riweather/parser.py</code> <pre><code>@computed_field\ndef temperature_f(self) -&gt; float | None:\n    \"\"\"The temperature of the air, in degrees Fahrenheit.\"\"\"\n    return self.temperature_c * 1.8 + 32 if self.temperature_c is not None else None\n</code></pre>"},{"location":"api/parser/#riweather.parser.AtmosphericPressureObservation","title":"riweather.parser.AtmosphericPressureObservation  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>An observation of current atmospheric pressure.</p> Show JSON schema: <pre><code>{\n  \"description\": \"An observation of current atmospheric pressure.\",\n  \"properties\": {\n    \"pressure\": {\n      \"anyOf\": [\n        {\n          \"type\": \"number\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"title\": \"Pressure\"\n    },\n    \"quality_code\": {\n      \"maxLength\": 1,\n      \"title\": \"Quality Code\",\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\n    \"pressure\",\n    \"quality_code\"\n  ],\n  \"title\": \"AtmosphericPressureObservation\",\n  \"type\": \"object\"\n}\n</code></pre> <p>Fields:</p> <ul> <li> <code>pressure</code>                 (<code>float | None</code>)             </li> <li> <code>quality_code</code>                 (<code>str</code>)             </li> </ul>"},{"location":"api/parser/#riweather.parser.AtmosphericPressureObservation.pressure","title":"pressure  <code>pydantic-field</code>","text":"<pre><code>pressure\n</code></pre> <p>Air pressure relative to Mean Sea Level (MSL).</p>"},{"location":"api/parser/#riweather.parser.AtmosphericPressureObservation.quality_code","title":"quality_code  <code>pydantic-field</code>","text":"<pre><code>quality_code\n</code></pre> <p>Quality status of the reported atmospheric pressure.</p> <p>Note</p> <p>Possible values</p>"},{"location":"api/rollup/","title":"Rollup functions","text":""},{"location":"api/rollup/#riweather.rollup_starting","title":"riweather.rollup_starting","text":"<pre><code>rollup_starting(data, period='h', *, upsample_first=True)\n</code></pre> <p>Roll up data, labelled with the period start.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Series | DataFrame</code>)           \u2013            <p>Time series data with a datetime index</p> </li> <li> <code>period</code>               (<code>str</code>, default:                   <code>'h'</code> )           \u2013            <p>Period to resample to. Defaults to <code>\"h\"</code>, which is hourly.</p> </li> <li> <code>upsample_first</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Perform minute-level upsampling prior to calculating the period average.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Series | DataFrame</code>           \u2013            <p>The time series rolled up to the specified period.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; t = pd.Series(\n...     [1, 2, 10],\n...     index=pd.date_range(\n...         \"2023-01-01 00:01\",\n...         \"2023-01-01 01:05\",\n...         freq=\"32min\",\n...     ),\n... )\n&gt;&gt;&gt; t\n2023-01-01 00:01:00     1\n2023-01-01 00:33:00     2\n2023-01-01 01:05:00    10\nFreq: 32min, dtype: int64\n</code></pre> <p>By default, the data are upsampled to minute-level before aggregation.</p> <pre><code>&gt;&gt;&gt; rollup_starting(t)\n2023-01-01 00:00:00    3.207627\n2023-01-01 01:00:00    9.375000\nFreq: h, dtype: float64\n</code></pre> <p>The above is equivalent to upsampling and then aggregating with Pandas <code>resample()</code>:</p> <pre><code>&gt;&gt;&gt; x = upsample(t, period=\"min\")\n&gt;&gt;&gt; x\n2023-01-01 00:01:00     1.00000\n2023-01-01 00:02:00     1.03125\n2023-01-01 00:03:00     1.06250\n2023-01-01 00:04:00     1.09375\n2023-01-01 00:05:00     1.12500\n                         ...\n2023-01-01 01:01:00     9.00000\n2023-01-01 01:02:00     9.25000\n2023-01-01 01:03:00     9.50000\n2023-01-01 01:04:00     9.75000\n2023-01-01 01:05:00    10.00000\nFreq: min, Length: 65, dtype: float64\n&gt;&gt;&gt; x.resample(\"h\").mean()\n2023-01-01 00:00:00    3.207627\n2023-01-01 01:00:00    9.375000\nFreq: h, dtype: float64\n</code></pre> <p>To skip upsampling and aggregate raw values only, use <code>upsample_first=False</code>.</p> <pre><code>&gt;&gt;&gt; rollup_starting(t, upsample_first=False)\n2023-01-01 00:00:00     1.5\n2023-01-01 01:00:00    10.0\nFreq: h, dtype: float64\n</code></pre> Source code in <code>src/riweather/stations.py</code> <pre><code>def rollup_starting(\n    data: pd.Series | pd.DataFrame, period: str = \"h\", *, upsample_first: bool = True\n) -&gt; pd.Series | pd.DataFrame:\n    \"\"\"Roll up data, labelled with the period start.\n\n    Args:\n        data: Time series data with a datetime index\n        period: Period to resample to. Defaults to `\"h\"`, which is hourly.\n        upsample_first: Perform minute-level upsampling prior to calculating\n            the period average.\n\n    Returns:\n        The time series rolled up to the specified period.\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; t = pd.Series(\n        ...     [1, 2, 10],\n        ...     index=pd.date_range(\n        ...         \"2023-01-01 00:01\",\n        ...         \"2023-01-01 01:05\",\n        ...         freq=\"32min\",\n        ...     ),\n        ... )\n        &gt;&gt;&gt; t\n        2023-01-01 00:01:00     1\n        2023-01-01 00:33:00     2\n        2023-01-01 01:05:00    10\n        Freq: 32min, dtype: int64\n\n        By default, the data are [upsampled][riweather.upsample] to minute-level before aggregation.\n\n        &gt;&gt;&gt; rollup_starting(t)\n        2023-01-01 00:00:00    3.207627\n        2023-01-01 01:00:00    9.375000\n        Freq: h, dtype: float64\n\n        The above is equivalent to upsampling and then aggregating with [Pandas `resample()`][pandas.Series.resample]:\n\n        &gt;&gt;&gt; x = upsample(t, period=\"min\")\n        &gt;&gt;&gt; x\n        2023-01-01 00:01:00     1.00000\n        2023-01-01 00:02:00     1.03125\n        2023-01-01 00:03:00     1.06250\n        2023-01-01 00:04:00     1.09375\n        2023-01-01 00:05:00     1.12500\n                                 ...\n        2023-01-01 01:01:00     9.00000\n        2023-01-01 01:02:00     9.25000\n        2023-01-01 01:03:00     9.50000\n        2023-01-01 01:04:00     9.75000\n        2023-01-01 01:05:00    10.00000\n        Freq: min, Length: 65, dtype: float64\n        &gt;&gt;&gt; x.resample(\"h\").mean()\n        2023-01-01 00:00:00    3.207627\n        2023-01-01 01:00:00    9.375000\n        Freq: h, dtype: float64\n\n        To skip upsampling and aggregate raw values only, use `upsample_first=False`.\n\n        &gt;&gt;&gt; rollup_starting(t, upsample_first=False)\n        2023-01-01 00:00:00     1.5\n        2023-01-01 01:00:00    10.0\n        Freq: h, dtype: float64\n    \"\"\"\n    if upsample_first:\n        data = upsample(data, period=\"min\")\n    return data.resample(period, label=\"left\", closed=\"left\").mean()\n</code></pre>"},{"location":"api/rollup/#riweather.rollup_ending","title":"riweather.rollup_ending","text":"<pre><code>rollup_ending(data, period='h', *, upsample_first=True)\n</code></pre> <p>Roll up data, labelled with the period end.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Series | DataFrame</code>)           \u2013            <p>Time series data with a datetime index</p> </li> <li> <code>period</code>               (<code>str</code>, default:                   <code>'h'</code> )           \u2013            <p>Period to resample to. Defaults to <code>\"h\"</code>, which is hourly.</p> </li> <li> <code>upsample_first</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Perform minute-level upsampling prior to calculating the period average.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Series | DataFrame</code>           \u2013            <p>The time series rolled up to the specified period.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; t = pd.Series(\n...     [1, 2, 10],\n...     index=pd.date_range(\n...         \"2023-01-01 00:01\",\n...         \"2023-01-01 01:05\",\n...         freq=\"32min\",\n...     ),\n... )\n&gt;&gt;&gt; t\n2023-01-01 00:01:00     1\n2023-01-01 00:33:00     2\n2023-01-01 01:05:00    10\nFreq: 32min, dtype: int64\n</code></pre> <p>By default, the data are upsampled to minute-level before aggregation.</p> <pre><code>&gt;&gt;&gt; rollup_ending(t)\n2023-01-01 01:00:00    3.3\n2023-01-01 02:00:00    9.5\nFreq: h, dtype: float64\n</code></pre> <p>The above is equivalent to upsampling and then aggregating with Pandas <code>resample()</code>:</p> <pre><code>&gt;&gt;&gt; x = upsample(t, period=\"min\")\n&gt;&gt;&gt; x\n2023-01-01 00:01:00     1.00000\n2023-01-01 00:02:00     1.03125\n2023-01-01 00:03:00     1.06250\n2023-01-01 00:04:00     1.09375\n2023-01-01 00:05:00     1.12500\n                         ...\n2023-01-01 01:01:00     9.00000\n2023-01-01 01:02:00     9.25000\n2023-01-01 01:03:00     9.50000\n2023-01-01 01:04:00     9.75000\n2023-01-01 01:05:00    10.00000\nFreq: min, Length: 65, dtype: float64\n&gt;&gt;&gt; x.resample(\"h\", label=\"right\", closed=\"right\").mean()\n2023-01-01 01:00:00    3.3\n2023-01-01 02:00:00    9.5\nFreq: h, dtype: float64\n</code></pre> <p>To skip upsampling and aggregate raw values only, use <code>upsample_first=False</code>.</p> <pre><code>&gt;&gt;&gt; rollup_ending(t, upsample_first=False)\n2023-01-01 01:00:00     1.5\n2023-01-01 02:00:00    10.0\nFreq: h, dtype: float64\n</code></pre> Source code in <code>src/riweather/stations.py</code> <pre><code>def rollup_ending(\n    data: pd.Series | pd.DataFrame, period: str = \"h\", *, upsample_first: bool = True\n) -&gt; pd.Series | pd.DataFrame:\n    \"\"\"Roll up data, labelled with the period end.\n\n    Args:\n        data: Time series data with a datetime index\n        period: Period to resample to. Defaults to `\"h\"`, which is hourly.\n        upsample_first: Perform minute-level upsampling prior to calculating\n            the period average.\n\n    Returns:\n        The time series rolled up to the specified period.\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; t = pd.Series(\n        ...     [1, 2, 10],\n        ...     index=pd.date_range(\n        ...         \"2023-01-01 00:01\",\n        ...         \"2023-01-01 01:05\",\n        ...         freq=\"32min\",\n        ...     ),\n        ... )\n        &gt;&gt;&gt; t\n        2023-01-01 00:01:00     1\n        2023-01-01 00:33:00     2\n        2023-01-01 01:05:00    10\n        Freq: 32min, dtype: int64\n\n        By default, the data are [upsampled][riweather.upsample] to minute-level before aggregation.\n\n        &gt;&gt;&gt; rollup_ending(t)\n        2023-01-01 01:00:00    3.3\n        2023-01-01 02:00:00    9.5\n        Freq: h, dtype: float64\n\n        The above is equivalent to upsampling and then aggregating with [Pandas `resample()`][pandas.Series.resample]:\n\n        &gt;&gt;&gt; x = upsample(t, period=\"min\")\n        &gt;&gt;&gt; x\n        2023-01-01 00:01:00     1.00000\n        2023-01-01 00:02:00     1.03125\n        2023-01-01 00:03:00     1.06250\n        2023-01-01 00:04:00     1.09375\n        2023-01-01 00:05:00     1.12500\n                                 ...\n        2023-01-01 01:01:00     9.00000\n        2023-01-01 01:02:00     9.25000\n        2023-01-01 01:03:00     9.50000\n        2023-01-01 01:04:00     9.75000\n        2023-01-01 01:05:00    10.00000\n        Freq: min, Length: 65, dtype: float64\n        &gt;&gt;&gt; x.resample(\"h\", label=\"right\", closed=\"right\").mean()\n        2023-01-01 01:00:00    3.3\n        2023-01-01 02:00:00    9.5\n        Freq: h, dtype: float64\n\n        To skip upsampling and aggregate raw values only, use `upsample_first=False`.\n\n        &gt;&gt;&gt; rollup_ending(t, upsample_first=False)\n        2023-01-01 01:00:00     1.5\n        2023-01-01 02:00:00    10.0\n        Freq: h, dtype: float64\n    \"\"\"\n    if upsample_first:\n        data = upsample(data, period=\"min\")\n    return data.resample(period, label=\"right\", closed=\"right\").mean()\n</code></pre>"},{"location":"api/rollup/#riweather.rollup_midpoint","title":"riweather.rollup_midpoint","text":"<pre><code>rollup_midpoint(data, period='h', *, upsample_first=True)\n</code></pre> <p>Roll up data, labelled with the period midpoint.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Series | DataFrame</code>)           \u2013            <p>Time series data with a datetime index</p> </li> <li> <code>period</code>               (<code>str</code>, default:                   <code>'h'</code> )           \u2013            <p>Period to resample to. Defaults to <code>\"h\"</code>, which is hourly.</p> </li> <li> <code>upsample_first</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Perform minute-level upsampling prior to calculating the period average.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Series | DataFrame</code>           \u2013            <p>The time series rolled up to the specified period.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; t = pd.Series(\n...     [1, 2, 10],\n...     index=pd.date_range(\n...         \"2023-01-01 00:01\",\n...         \"2023-01-01 01:05\",\n...         freq=\"32min\",\n...     ),\n... )\n&gt;&gt;&gt; t\n2023-01-01 00:01:00     1\n2023-01-01 00:33:00     2\n2023-01-01 01:05:00    10\nFreq: 32min, dtype: int64\n</code></pre> <p>By default, the data are upsampled to minute-level before aggregation.</p> <pre><code>&gt;&gt;&gt; rollup_midpoint(t)\n2023-01-01 00:00:00    1.437500\n2023-01-01 01:00:00    5.661458\nFreq: h, dtype: float64\n</code></pre> <p>The above is equivalent to upsampling, shifting the data forward by half of the period, and then aggregating with Pandas <code>resample()</code>:</p> <pre><code>&gt;&gt;&gt; x = upsample(t, period=\"min\")\n&gt;&gt;&gt; x\n2023-01-01 00:01:00     1.00000\n2023-01-01 00:02:00     1.03125\n2023-01-01 00:03:00     1.06250\n2023-01-01 00:04:00     1.09375\n2023-01-01 00:05:00     1.12500\n                         ...\n2023-01-01 01:01:00     9.00000\n2023-01-01 01:02:00     9.25000\n2023-01-01 01:03:00     9.50000\n2023-01-01 01:04:00     9.75000\n2023-01-01 01:05:00    10.00000\nFreq: min, Length: 65, dtype: float64\n&gt;&gt;&gt; x.shift(freq=\"30min\").resample(\"h\").mean()\n2023-01-01 00:00:00    1.437500\n2023-01-01 01:00:00    5.661458\nFreq: h, dtype: float64\n</code></pre> <p>To skip upsampling and aggregate raw values only, use <code>upsample_first=False</code>.</p> <pre><code>&gt;&gt;&gt; rollup_midpoint(t, upsample_first=False)\n2023-01-01 00:00:00    1.0\n2023-01-01 01:00:00    6.0\nFreq: h, dtype: float64\n</code></pre> Source code in <code>src/riweather/stations.py</code> <pre><code>def rollup_midpoint(\n    data: pd.Series | pd.DataFrame, period: str = \"h\", *, upsample_first: bool = True\n) -&gt; pd.Series | pd.DataFrame:\n    \"\"\"Roll up data, labelled with the period midpoint.\n\n    Args:\n        data: Time series data with a datetime index\n        period: Period to resample to. Defaults to `\"h\"`, which is hourly.\n        upsample_first: Perform minute-level upsampling prior to calculating\n            the period average.\n\n    Returns:\n        The time series rolled up to the specified period.\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; t = pd.Series(\n        ...     [1, 2, 10],\n        ...     index=pd.date_range(\n        ...         \"2023-01-01 00:01\",\n        ...         \"2023-01-01 01:05\",\n        ...         freq=\"32min\",\n        ...     ),\n        ... )\n        &gt;&gt;&gt; t\n        2023-01-01 00:01:00     1\n        2023-01-01 00:33:00     2\n        2023-01-01 01:05:00    10\n        Freq: 32min, dtype: int64\n\n        By default, the data are [upsampled][riweather.upsample] to minute-level before aggregation.\n\n        &gt;&gt;&gt; rollup_midpoint(t)\n        2023-01-01 00:00:00    1.437500\n        2023-01-01 01:00:00    5.661458\n        Freq: h, dtype: float64\n\n        The above is equivalent to upsampling, [shifting][pandas.Series.shift] the data forward\n        by half of the period, and then aggregating with [Pandas `resample()`][pandas.Series.resample]:\n\n        &gt;&gt;&gt; x = upsample(t, period=\"min\")\n        &gt;&gt;&gt; x\n        2023-01-01 00:01:00     1.00000\n        2023-01-01 00:02:00     1.03125\n        2023-01-01 00:03:00     1.06250\n        2023-01-01 00:04:00     1.09375\n        2023-01-01 00:05:00     1.12500\n                                 ...\n        2023-01-01 01:01:00     9.00000\n        2023-01-01 01:02:00     9.25000\n        2023-01-01 01:03:00     9.50000\n        2023-01-01 01:04:00     9.75000\n        2023-01-01 01:05:00    10.00000\n        Freq: min, Length: 65, dtype: float64\n        &gt;&gt;&gt; x.shift(freq=\"30min\").resample(\"h\").mean()\n        2023-01-01 00:00:00    1.437500\n        2023-01-01 01:00:00    5.661458\n        Freq: h, dtype: float64\n\n        To skip upsampling and aggregate raw values only, use `upsample_first=False`.\n\n        &gt;&gt;&gt; rollup_midpoint(t, upsample_first=False)\n        2023-01-01 00:00:00    1.0\n        2023-01-01 01:00:00    6.0\n        Freq: h, dtype: float64\n    \"\"\"\n    if upsample_first:\n        data = upsample(data, period=\"min\")\n    half_period = to_offset(period) / 2\n    return data.shift(freq=half_period).resample(period, label=\"left\", closed=\"left\").mean()\n</code></pre>"},{"location":"api/rollup/#riweather.rollup_instant","title":"riweather.rollup_instant","text":"<pre><code>rollup_instant(data, period='h', *, upsample_first=True)\n</code></pre> <p>Roll up data, labelled with interpolated values.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Series | DataFrame</code>)           \u2013            <p>Time series data with a datetime index</p> </li> <li> <code>period</code>               (<code>str</code>, default:                   <code>'h'</code> )           \u2013            <p>Period to resample to. Defaults to <code>h</code>, which is hourly.</p> </li> <li> <code>upsample_first</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Perform minute-level upsampling prior to returning a value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Series | DataFrame</code>           \u2013            <p>The time series aligned to the specified period.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; t = pd.Series(\n...     [1, 2, 10],\n...     index=pd.date_range(\n...         \"2023-01-01 00:01\",\n...         \"2023-01-01 01:05\",\n...         freq=\"32min\",\n...     ),\n... )\n&gt;&gt;&gt; t\n2023-01-01 00:01:00     1\n2023-01-01 00:33:00     2\n2023-01-01 01:05:00    10\nFreq: 32min, dtype: int64\n</code></pre> <p>By default, the data are upsampled to minute-level before aggregation.</p> <pre><code>&gt;&gt;&gt; rollup_instant(t)\n2023-01-01 00:00:00    1.00\n2023-01-01 01:00:00    8.75\nFreq: h, dtype: float64\n</code></pre> <p>The above is equivalent to upsampling and then aggregating with Pandas <code>resample()</code>, but instead of taking the mean over each time period, taking the first value:</p> <pre><code>&gt;&gt;&gt; x = upsample(t, period=\"min\")\n&gt;&gt;&gt; x\n2023-01-01 00:01:00     1.00000\n2023-01-01 00:02:00     1.03125\n2023-01-01 00:03:00     1.06250\n2023-01-01 00:04:00     1.09375\n2023-01-01 00:05:00     1.12500\n                         ...\n2023-01-01 01:01:00     9.00000\n2023-01-01 01:02:00     9.25000\n2023-01-01 01:03:00     9.50000\n2023-01-01 01:04:00     9.75000\n2023-01-01 01:05:00    10.00000\nFreq: min, Length: 65, dtype: float64\n&gt;&gt;&gt; x.resample(\"h\").first()\n2023-01-01 00:00:00    1.00\n2023-01-01 01:00:00    8.75\nFreq: h, dtype: float64\n</code></pre> <p>To skip upsampling and aggregate raw values only, use <code>upsample_first=False</code>. Notice that this is simply the first value in every time period (hour by default).</p> <pre><code>&gt;&gt;&gt; rollup_instant(t, upsample_first=False)\n2023-01-01 00:00:00     1\n2023-01-01 01:00:00    10\nFreq: h, dtype: int64\n</code></pre> Source code in <code>src/riweather/stations.py</code> <pre><code>def rollup_instant(\n    data: pd.Series | pd.DataFrame, period: str = \"h\", *, upsample_first: bool = True\n) -&gt; pd.Series | pd.DataFrame:\n    \"\"\"Roll up data, labelled with interpolated values.\n\n    Args:\n        data: Time series data with a datetime index\n        period: Period to resample to. Defaults to `h`, which is hourly.\n        upsample_first: Perform minute-level upsampling prior to returning\n            a value.\n\n    Returns:\n        The time series aligned to the specified period.\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; t = pd.Series(\n        ...     [1, 2, 10],\n        ...     index=pd.date_range(\n        ...         \"2023-01-01 00:01\",\n        ...         \"2023-01-01 01:05\",\n        ...         freq=\"32min\",\n        ...     ),\n        ... )\n        &gt;&gt;&gt; t\n        2023-01-01 00:01:00     1\n        2023-01-01 00:33:00     2\n        2023-01-01 01:05:00    10\n        Freq: 32min, dtype: int64\n\n        By default, the data are [upsampled][riweather.upsample] to minute-level before aggregation.\n\n        &gt;&gt;&gt; rollup_instant(t)\n        2023-01-01 00:00:00    1.00\n        2023-01-01 01:00:00    8.75\n        Freq: h, dtype: float64\n\n        The above is equivalent to upsampling and then aggregating with [Pandas `resample()`][pandas.Series.resample],\n        but instead of taking the mean over each time period, taking the first value:\n\n        &gt;&gt;&gt; x = upsample(t, period=\"min\")\n        &gt;&gt;&gt; x\n        2023-01-01 00:01:00     1.00000\n        2023-01-01 00:02:00     1.03125\n        2023-01-01 00:03:00     1.06250\n        2023-01-01 00:04:00     1.09375\n        2023-01-01 00:05:00     1.12500\n                                 ...\n        2023-01-01 01:01:00     9.00000\n        2023-01-01 01:02:00     9.25000\n        2023-01-01 01:03:00     9.50000\n        2023-01-01 01:04:00     9.75000\n        2023-01-01 01:05:00    10.00000\n        Freq: min, Length: 65, dtype: float64\n        &gt;&gt;&gt; x.resample(\"h\").first()\n        2023-01-01 00:00:00    1.00\n        2023-01-01 01:00:00    8.75\n        Freq: h, dtype: float64\n\n        To skip upsampling and aggregate raw values only, use `upsample_first=False`. Notice that\n        this is simply the first value in every time period (hour by default).\n\n        &gt;&gt;&gt; rollup_instant(t, upsample_first=False)\n        2023-01-01 00:00:00     1\n        2023-01-01 01:00:00    10\n        Freq: h, dtype: int64\n    \"\"\"\n    if upsample_first:\n        data = upsample(data, period=\"min\")\n    return data.resample(period, label=\"left\", closed=\"left\").first()\n</code></pre>"},{"location":"api/rollup/#riweather.upsample","title":"riweather.upsample","text":"<pre><code>upsample(data, period='min')\n</code></pre> <p>Upsample and interpolate time series data.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>Series | DataFrame</code>)           \u2013            <p>Time series data with a datetime index</p> </li> <li> <code>period</code>               (<code>str</code>, default:                   <code>'min'</code> )           \u2013            <p>Period to upsample to. Defaults to <code>\"min\"</code>, which is minute-level</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Series | DataFrame</code>           \u2013            <p>Upsampled data</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; t = pd.Series(\n...     [1, 2, 10],\n...     index=pd.date_range(\n...         \"2023-01-01 00:01\",\n...         \"2023-01-01 01:05\",\n...         freq=\"32min\",\n...     ),\n... )\n&gt;&gt;&gt; upsample(t)\n2023-01-01 00:01:00     1.00000\n2023-01-01 00:02:00     1.03125\n2023-01-01 00:03:00     1.06250\n2023-01-01 00:04:00     1.09375\n2023-01-01 00:05:00     1.12500\n                         ...\n2023-01-01 01:01:00     9.00000\n2023-01-01 01:02:00     9.25000\n2023-01-01 01:03:00     9.50000\n2023-01-01 01:04:00     9.75000\n2023-01-01 01:05:00    10.00000\nFreq: min, Length: 65, dtype: float64\n</code></pre> <p>You can upsample to a different frequency if you want.</p> <pre><code>&gt;&gt;&gt; upsample(t, period=\"5min\")\n2023-01-01 00:00:00     1.000000\n2023-01-01 00:05:00     1.166667\n2023-01-01 00:10:00     1.333333\n2023-01-01 00:15:00     1.500000\n2023-01-01 00:20:00     1.666667\n2023-01-01 00:25:00     1.833333\n2023-01-01 00:30:00     2.000000\n2023-01-01 00:35:00     3.142857\n2023-01-01 00:40:00     4.285714\n2023-01-01 00:45:00     5.428571\n2023-01-01 00:50:00     6.571429\n2023-01-01 00:55:00     7.714286\n2023-01-01 01:00:00     8.857143\n2023-01-01 01:05:00    10.000000\nFreq: 5min, dtype: float64\n</code></pre> Source code in <code>src/riweather/stations.py</code> <pre><code>def upsample(data: pd.Series | pd.DataFrame, period: str = \"min\") -&gt; pd.Series | pd.DataFrame:\n    \"\"\"Upsample and interpolate time series data.\n\n    Args:\n        data: Time series data with a datetime index\n        period: Period to upsample to. Defaults to `\"min\"`, which is minute-level\n\n    Returns:\n        Upsampled data\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; t = pd.Series(\n        ...     [1, 2, 10],\n        ...     index=pd.date_range(\n        ...         \"2023-01-01 00:01\",\n        ...         \"2023-01-01 01:05\",\n        ...         freq=\"32min\",\n        ...     ),\n        ... )\n        &gt;&gt;&gt; upsample(t)\n        2023-01-01 00:01:00     1.00000\n        2023-01-01 00:02:00     1.03125\n        2023-01-01 00:03:00     1.06250\n        2023-01-01 00:04:00     1.09375\n        2023-01-01 00:05:00     1.12500\n                                 ...\n        2023-01-01 01:01:00     9.00000\n        2023-01-01 01:02:00     9.25000\n        2023-01-01 01:03:00     9.50000\n        2023-01-01 01:04:00     9.75000\n        2023-01-01 01:05:00    10.00000\n        Freq: min, Length: 65, dtype: float64\n\n        You can upsample to a different frequency if you want.\n\n        &gt;&gt;&gt; upsample(t, period=\"5min\")\n        2023-01-01 00:00:00     1.000000\n        2023-01-01 00:05:00     1.166667\n        2023-01-01 00:10:00     1.333333\n        2023-01-01 00:15:00     1.500000\n        2023-01-01 00:20:00     1.666667\n        2023-01-01 00:25:00     1.833333\n        2023-01-01 00:30:00     2.000000\n        2023-01-01 00:35:00     3.142857\n        2023-01-01 00:40:00     4.285714\n        2023-01-01 00:45:00     5.428571\n        2023-01-01 00:50:00     6.571429\n        2023-01-01 00:55:00     7.714286\n        2023-01-01 01:00:00     8.857143\n        2023-01-01 01:05:00    10.000000\n        Freq: 5min, dtype: float64\n    \"\"\"\n    return data.resample(period).mean().interpolate(method=\"linear\", limit=60, limit_direction=\"both\")\n</code></pre>"},{"location":"api/station/","title":"Station","text":""},{"location":"api/station/#riweather.Station","title":"riweather.Station","text":"<pre><code>Station(usaf_id, *, load_metadata_on_init=True)\n</code></pre> <p>ISD Station object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; s = Station(\"720534\")\n&gt;&gt;&gt; s\nStation(\"720534\")\n&gt;&gt;&gt; print(s.name, s.latitude, s.longitude)\nERIE MUNICIPAL AIRPORT 40.017 -105.05\n</code></pre> <p>Parameters:</p> <ul> <li> <code>usaf_id</code>               (<code>str</code>)           \u2013            <p>USAF identifier</p> </li> <li> <code>load_metadata_on_init</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, station metadata will be retrieved from the local data store and loaded into the object as properties.</p> </li> </ul> Source code in <code>src/riweather/stations.py</code> <pre><code>def __init__(self, usaf_id: str, *, load_metadata_on_init: bool = True) -&gt; None:\n    \"\"\"Initialize a station.\n\n    Args:\n        usaf_id: USAF identifier\n        load_metadata_on_init: If `True`, station metadata will be retrieved\n            from the local data store and loaded into the object as\n            properties.\n    \"\"\"\n    self.usaf_id = usaf_id\n\n    if load_metadata_on_init:\n        self._station = self._load_metadata()\n    else:\n        self._station = {}\n</code></pre>"},{"location":"api/station/#riweather.Station.wban_ids","title":"wban_ids  <code>property</code>","text":"<pre><code>wban_ids\n</code></pre> <p>List of valid WBAN (Weather Bureau Army Navy) identifiers.</p>"},{"location":"api/station/#riweather.Station.recent_wban_id","title":"recent_wban_id  <code>property</code>","text":"<pre><code>recent_wban_id\n</code></pre> <p>Most recent WBAN (Weather Bureau Army Navy) identifier.</p>"},{"location":"api/station/#riweather.Station.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>Station name.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; s = Station(\"720534\")\n&gt;&gt;&gt; s.name\n'ERIE MUNICIPAL AIRPORT'\n</code></pre>"},{"location":"api/station/#riweather.Station.icao_code","title":"icao_code  <code>property</code>","text":"<pre><code>icao_code\n</code></pre> <p>ICAO airport code.</p>"},{"location":"api/station/#riweather.Station.latitude","title":"latitude  <code>property</code>","text":"<pre><code>latitude\n</code></pre> <p>Station latitude.</p>"},{"location":"api/station/#riweather.Station.longitude","title":"longitude  <code>property</code>","text":"<pre><code>longitude\n</code></pre> <p>Station longitude.</p>"},{"location":"api/station/#riweather.Station.elevation","title":"elevation  <code>property</code>","text":"<pre><code>elevation\n</code></pre> <p>Elevation of the station, in meters.</p>"},{"location":"api/station/#riweather.Station.state","title":"state  <code>property</code>","text":"<pre><code>state\n</code></pre> <p>US state in which the station is located.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; s = Station(\"720534\")\n&gt;&gt;&gt; s.state\n'CO'\n</code></pre>"},{"location":"api/station/#riweather.Station.years","title":"years  <code>property</code>","text":"<pre><code>years\n</code></pre> <p>Years for which data exists for the station.</p>"},{"location":"api/station/#riweather.Station.get_filenames","title":"get_filenames","text":"<pre><code>get_filenames(year=None)\n</code></pre> <p>Construct the names of ISD files corresponding to this station.</p> <p>Parameters:</p> <ul> <li> <code>year</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Limit the filenames to the one corresponding to the given year. If <code>None</code>, filenames for all years are returned.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>List of filenames</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; s = Station(\"720534\")\n&gt;&gt;&gt; print(s.get_filenames(2022))\n['/pub/data/noaa/2022/720534-00161-2022.gz']\n</code></pre> Source code in <code>src/riweather/stations.py</code> <pre><code>def get_filenames(self, year: int | None = None) -&gt; list[str]:\n    \"\"\"Construct the names of ISD files corresponding to this station.\n\n    Args:\n        year: Limit the filenames to the one corresponding to the given year.\n            If `None`, filenames for all years are returned.\n\n    Returns:\n        List of filenames\n\n    Examples:\n        &gt;&gt;&gt; s = Station(\"720534\")\n        &gt;&gt;&gt; print(s.get_filenames(2022))\n        ['/pub/data/noaa/2022/720534-00161-2022.gz']\n    \"\"\"\n    stmt = select(models.FileCount).where(models.FileCount.station_id == self._station.get(\"id\"))\n    if year is not None:\n        stmt = stmt.where(models.FileCount.year == year)\n\n    filename_template = \"/pub/data/noaa/{2}/{0}-{1}-{2}.gz\"\n    filenames = []\n    with MetadataSession() as session:\n        for row in session.scalars(stmt):\n            filenames.append(  # noqa: PERF401\n                filename_template.format(self.usaf_id, row.wban_id, row.year)\n            )\n\n    if len(filenames) == 0:\n        filenames = [filename_template.format(self.usaf_id, self.recent_wban_id, year)]\n        msg = (\n            \"A record for station {} and year {} was not found in riweather's metadata. \"\n            \"Trying to fetch data directly from the following URL, which may not exist: {}\"\n        ).format(self._station.get(\"usaf_id\"), year, filenames[0])\n        warnings.warn(msg, UserWarning, stacklevel=3)\n\n    return filenames\n</code></pre>"},{"location":"api/station/#riweather.Station.quality_report","title":"quality_report","text":"<pre><code>quality_report(year=None)\n</code></pre> <p>Retrieve information on data quality.</p> <p>Parameters:</p> <ul> <li> <code>year</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Limit the report to information concerning the given year. If <code>None</code>, all years are included.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame | Series</code>           \u2013            <p>Data quality report</p> </li> </ul> Source code in <code>src/riweather/stations.py</code> <pre><code>def quality_report(self, year: int | None = None) -&gt; pd.DataFrame | pd.Series:\n    \"\"\"Retrieve information on data quality.\n\n    Args:\n        year: Limit the report to information concerning the given year.\n            If `None`, all years are included.\n\n    Returns:\n        Data quality report\n    \"\"\"\n    stmt = select(models.FileCount).where(models.FileCount.station_id == self._station.get(\"id\"))\n    if year is not None:\n        stmt = stmt.where(models.FileCount.year == year)\n\n    with MetadataSession() as session:\n        results = [\n            {\n                \"usaf_id\": r.station.usaf_id,\n                \"wban_id\": r.wban_id,\n                \"year\": r.year,\n                \"quality\": r.quality,\n                \"jan\": r.jan,\n                \"feb\": r.feb,\n                \"mar\": r.mar,\n                \"apr\": r.apr,\n                \"may\": r.may,\n                \"jun\": r.jun,\n                \"jul\": r.jul,\n                \"aug\": r.aug,\n                \"sep\": r.sep,\n                \"oct\": r.oct,\n                \"nov\": r.nov,\n                \"dec\": r.dec,\n                \"count\": r.count,\n                \"n_zero_months\": r.n_zero_months,\n            }\n            for r in session.scalars(stmt).all()\n        ]\n\n    return pd.DataFrame(results).squeeze()\n</code></pre>"},{"location":"api/station/#riweather.Station.fetch_raw_data","title":"fetch_raw_data","text":"<pre><code>fetch_raw_data(year, *, use_http=False)\n</code></pre> <p>Fetch data from ISD.</p> <p>Parameters:</p> <ul> <li> <code>year</code>               (<code>int | list[int]</code>)           \u2013            <p>Year or years of data to fetch.</p> </li> <li> <code>use_http</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Use NOAA\u2019s HTTP server instead of their FTP server. Set this to <code>True</code> if you are running into issues with FTP.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[ISDRecord]</code>           \u2013            <p>A list of data records from the ISD database.</p> </li> </ul> Source code in <code>src/riweather/stations.py</code> <pre><code>def fetch_raw_data(self, year: int | list[int], *, use_http: bool = False) -&gt; list[ISDRecord]:\n    \"\"\"Fetch data from ISD.\n\n    Args:\n        year: Year or years of data to fetch.\n        use_http: Use NOAA's HTTP server instead of their FTP server. Set\n            this to ``True`` if you are running into issues with FTP.\n\n    Returns:\n        A list of data records from the ISD database.\n    \"\"\"\n    if not isinstance(year, list):\n        year = [year]\n\n    filenames = [f for y in year for f in self.get_filenames(y)]\n    connector = NOAAHTTPConnection if use_http else NOAAFTPConnection\n\n    with connector() as conn:\n        return [\n            parser.parse_line(line.decode(\"utf-8\"))\n            for filename in filenames\n            for line in conn.read_file_as_bytes(filename)\n        ]\n</code></pre>"},{"location":"api/station/#riweather.Station.fetch_data","title":"fetch_data","text":"<pre><code>fetch_data(\n    year,\n    datum=None,\n    *,\n    period=None,\n    rollup=\"ending\",\n    upsample_first=True,\n    tz=\"UTC\",\n    include_control=False,\n    include_quality_codes=True,\n    temp_scale=None,\n    model_dump_include=None,\n    model_dump_exclude=None,\n    use_http=False,\n)\n</code></pre> <p>Fetch data from ISD and return it as a DataFrame.</p> <p>Parameters:</p> <ul> <li> <code>year</code>               (<code>int | list[int]</code>)           \u2013            <p>Year or years of data to fetch.</p> </li> <li> <code>datum</code>               (<code>str | list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Data elements to include in the results. Must be one or more of the mandatory data fields:</p> <ul> <li><code>'wind'</code></li> <li><code>'ceiling'</code></li> <li><code>'visibility'</code></li> <li><code>'air_temperature'</code></li> <li><code>'dew_point'</code></li> <li><code>'sea_level_pressure'</code></li> </ul> <p>If not specified, all data are returned.</p> </li> <li> <code>period</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The time step at which the data will be returned. If <code>None</code>, the default, the data is returned at the original times they were observed. If specified, it must be a frequency string recognized by Pandas such as <code>'h'</code> for hourly and <code>'15min'</code> for every 15 minutes (see the docs on frequency strings). The data will be resampled to the given frequency.</p> </li> <li> <code>rollup</code>               (<code>str</code>, default:                   <code>'ending'</code> )           \u2013            <p>How to align values to the <code>period</code>. Defaults to <code>'ending'</code>, meaning that values over the previous time period are averaged. Can also be <code>'starting'</code>, <code>'midpoint'</code>, or <code>'instant'</code>. If <code>period=None</code>, this value is ignored.</p> </li> <li> <code>upsample_first</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to upsample the data to the minute level prior to resampling. Upsampling is recommended because it gives more accurate representations of the weather observations, so it defaults to <code>True</code>.</p> </li> <li> <code>tz</code>               (<code>str</code>, default:                   <code>'UTC'</code> )           \u2013            <p>The timestamps of each observation are returned from the ISD in UTC. If this parameter is set, the data will be converted to the specified timezone. The timezone string should match one of the standard TZ identifiers, e.g. <code>'US/Eastern'</code>, <code>'US/Central'</code>, <code>'US/Mountain'</code>, <code>'US/Pacific'</code>, etc.</p> </li> <li> <code>include_control</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, include the control data fields in the results.</p> </li> <li> <code>include_quality_codes</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>False</code>, filter out all the quality code fields from the results. These are columns that end in the string <code>'quality_code'</code>.</p> </li> <li> <code>temp_scale</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>By default, when <code>'air_temperature'</code> or <code>'dew_point'</code> are specified as a datum, temperatures are returned in both degrees Celsius and degrees Fahrenheit. To only include one or the other, set <code>temp_scale</code> to <code>'C'</code> or <code>'F'</code>. Ignored if no temperature values are meant to be retrieved.</p> </li> <li> <code>model_dump_include</code>               (<code>IncEx | None</code>, default:                   <code>None</code> )           \u2013            <p>Fine-grained control over the fields that are returned. Passed directly to <code>pydantic.BaseModel.model_dump</code> as the <code>include</code> parameter; see the docs for details. Takes precendence over <code>datum</code>.</p> </li> <li> <code>model_dump_exclude</code>               (<code>IncEx | None</code>, default:                   <code>None</code> )           \u2013            <p>Fine-grained control over the fields that are returned. Passed directly to <code>pydantic.BaseModel.model_dump</code> as the <code>exclude</code> parameter; see the docs for details. Takes precendence over <code>datum</code>.</p> </li> <li> <code>use_http</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Use NOAA\u2019s HTTP server instead of their FTP server. Set this to <code>True</code> if you are running into issues with FTP.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Weather observations from the station.</p> </li> </ul> Source code in <code>src/riweather/stations.py</code> <pre><code>def fetch_data(\n    self,\n    year: int | list[int],\n    datum: str | list[str] | None = None,\n    *,\n    period: str | None = None,\n    rollup: str = \"ending\",\n    upsample_first: bool = True,\n    tz: str = \"UTC\",\n    include_control: bool = False,\n    include_quality_codes: bool = True,\n    temp_scale: str | None = None,\n    model_dump_include: IncEx | None = None,\n    model_dump_exclude: IncEx | None = None,\n    use_http: bool = False,\n) -&gt; pd.DataFrame:\n    \"\"\"Fetch data from ISD and return it as a [DataFrame][pandas.DataFrame].\n\n    Args:\n        year: Year or years of data to fetch.\n        datum: Data elements to include in the results. Must be one or more of the\n            [mandatory data fields][riweather.parser.MandatoryData]:\n\n            * ``'wind'``\n            * ``'ceiling'``\n            * ``'visibility'``\n            * ``'air_temperature'``\n            * ``'dew_point'``\n            * ``'sea_level_pressure'``\n\n            If not specified, all data are returned.\n        period: The time step at which the data will be returned. If ``None``, the default, the\n            data is returned at the original times they were observed. If specified, it must be\n            a frequency string recognized by [Pandas][] such as ``'h'`` for hourly and ``'15min'``\n            for every 15 minutes (see the [docs on frequency strings](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects)).\n            The data will be [resampled](https://pandas.pydata.org/docs/user_guide/timeseries.html#resampling)\n            to the given frequency.\n        rollup: How to align values to the ``period``. Defaults to ``'ending'``, meaning that values\n            over the previous time period are averaged. Can also be ``'starting'``, ``'midpoint'``,\n            or ``'instant'``. If ``period=None``, this value is ignored.\n        upsample_first: Whether to upsample the data to the minute level prior to resampling.\n            Upsampling is recommended because it gives more accurate representations of the\n            weather observations, so it defaults to ``True``.\n        tz: The timestamps of each observation are returned from the ISD in\n            [UTC](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). If this parameter\n            is set, the data will be converted to the specified timezone. The timezone string\n            should match one of the\n            [standard TZ identifiers](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones),\n            e.g. ``'US/Eastern'``, ``'US/Central'``, ``'US/Mountain'``, ``'US/Pacific'``, etc.\n        include_control: If ``True``, include the [control data fields][riweather.parser.ControlData]\n            in the results.\n        include_quality_codes: If ``False``, filter out all the quality code fields from the\n            results. These are columns that end in the string ``'quality_code'``.\n        temp_scale: By default, when ``'air_temperature'`` or ``'dew_point'`` are specified as\n            a datum, temperatures are returned in both degrees Celsius and degrees Fahrenheit.\n            To only include one or the other, set ``temp_scale`` to ``'C'`` or ``'F'``. Ignored\n            if no temperature values are meant to be retrieved.\n        model_dump_include: Fine-grained control over the fields that are returned. Passed\n            directly to [``pydantic.BaseModel.model_dump``][] as the `include` parameter; see the\n            docs for details. Takes precendence over ``datum``.\n        model_dump_exclude: Fine-grained control over the fields that are returned. Passed\n            directly to [``pydantic.BaseModel.model_dump``][] as the `exclude` parameter; see the\n            docs for details. Takes precendence over ``datum``.\n        use_http: Use NOAA's HTTP server instead of their FTP server. Set this to ``True`` if\n            you are running into issues with FTP.\n\n    Returns:\n        Weather observations from the station.\n    \"\"\"\n    if datum is not None:\n        if not isinstance(datum, list):\n            datum = [datum]\n\n        if not all(d in MandatoryData.model_fields for d in datum):\n            msg = f\"datum must be a subset of the following: {list(MandatoryData.model_fields)}\"\n            raise ValueError(msg)\n\n    if rollup not in (\"starting\", \"ending\", \"midpoint\", \"instant\"):\n        msg = \"Invalid rollup\"\n        raise ValueError(msg)\n\n    data = self.fetch_raw_data(year, use_http=use_http)\n    timestamps = pd.DatetimeIndex([d.control.dt for d in data])\n\n    if include_control:\n        df_control = pd.json_normalize([d.control.model_dump(exclude={\"dt\"}) for d in data])\n        df_control.index = timestamps\n    else:\n        df_control = pd.DataFrame()\n\n    if model_dump_include is not None or model_dump_exclude is not None:\n        data_pydantic_dumps = [\n            d.mandatory.model_dump(include=model_dump_include, exclude=model_dump_exclude) for d in data\n        ]\n    else:\n        data_pydantic_dumps = [d.mandatory.model_dump(include=datum) for d in data]\n\n    df_mandatory = pd.json_normalize(data_pydantic_dumps)\n    df_mandatory.index = timestamps\n\n    df = pd.concat([df_control, df_mandatory], axis=1)\n    if not include_quality_codes:\n        df = df.loc[:, df.columns[~df.columns.str.contains(\"quality_code\")]]\n    if temp_scale is not None:\n        if temp_scale.lower() == \"c\":\n            df = df.loc[:, df.columns[~df.columns.str.contains(\"temperature_f\")]]\n        elif temp_scale.lower() == \"f\":\n            df = df.loc[:, df.columns[~df.columns.str.contains(\"temperature_c\")]]\n\n    if period is not None:\n        cols_to_keep = [f\"{k}.{vv}\" for k, v in _AGGREGABLE_FIELDS.items() for vv in v]\n        df = df.loc[:, [c for c in df.columns if c in cols_to_keep]]\n\n        if rollup == \"starting\":\n            df = rollup_starting(df, period, upsample_first=upsample_first)\n        elif rollup == \"ending\":\n            df = rollup_ending(df, period, upsample_first=upsample_first)\n        elif rollup == \"midpoint\":\n            df = rollup_midpoint(df, period, upsample_first=upsample_first)\n        elif rollup == \"instant\":\n            df = rollup_instant(df, period, upsample_first=upsample_first)\n\n    if tz != \"UTC\":\n        df = df.tz_convert(tz)\n    return df\n</code></pre>"},{"location":"api/station/#riweather.Station.fetch_raw_temp_data","title":"fetch_raw_temp_data","text":"<pre><code>fetch_raw_temp_data(year=None, scale='C', *, use_http=False)\n</code></pre> <p>Retrieve raw weather data from the ISD.</p> <p>Warning</p> <p>This has been deprecated and will be removed in a future release. Please consider using <code>riweather.Station.fetch_data</code> instead.</p> <p>Parameters:</p> <ul> <li> <code>year</code>               (<code>int | list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Returned data will be limited to the year(s) specified. If <code>None</code>, data for all years is returned.</p> </li> <li> <code>scale</code>               (<code>str</code>, default:                   <code>'C'</code> )           \u2013            <p>Return the temperature in Celsius (<code>\"C\"</code>, the default) or Fahrenheit (<code>\"F\"</code>).</p> </li> <li> <code>use_http</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Use NOAA\u2019s HTTP server instead of their FTP server. Set this to <code>True</code> if you are running into issues with FTP.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A DataFrame, indexed on the timestamp, with two columns: air temperature and dew point temperature.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; s = Station(\"720534\")\n&gt;&gt;&gt; print(s.fetch_raw_temp_data(2022).head(2))\n                           wind_dir  wind_speed  tempC  dewC\n2022-01-01 00:15:00+00:00      80.0         4.6   -2.8  -4.0\n2022-01-01 00:35:00+00:00      60.0         4.1   -4.2  -5.5\n</code></pre> Source code in <code>src/riweather/stations.py</code> <pre><code>def fetch_raw_temp_data(\n    self,\n    year: int | list[int] | None = None,\n    scale: str = \"C\",\n    *,\n    use_http: bool = False,\n) -&gt; pd.DataFrame:\n    \"\"\"Retrieve raw weather data from the ISD.\n\n    !!! warning\n        This has been deprecated and will be removed in a future release. Please consider using\n        [`riweather.Station.fetch_data`][] instead.\n\n    Args:\n        year: Returned data will be limited to the year(s) specified. If\n            `None`, data for all years is returned.\n        scale: Return the temperature in Celsius (`\"C\"`, the default) or\n            Fahrenheit (`\"F\"`).\n        use_http: Use NOAA's HTTP server instead of their FTP server. Set\n            this to ``True`` if you are running into issues with FTP.\n\n    Returns:\n        A [DataFrame][pandas.DataFrame], indexed on the timestamp, with two columns:\n            air temperature and dew point temperature.\n\n    Examples:\n        &gt;&gt;&gt; s = Station(\"720534\")\n        &gt;&gt;&gt; print(s.fetch_raw_temp_data(2022).head(2))  # doctest: +SKIP\n                                   wind_dir  wind_speed  tempC  dewC\n        2022-01-01 00:15:00+00:00      80.0         4.6   -2.8  -4.0\n        2022-01-01 00:35:00+00:00      60.0         4.1   -4.2  -5.5\n    \"\"\"\n    msg = \"fetch_raw_temp_data is deprecated. Please use fetch_raw_data() in the future.\"\n    warnings.warn(DeprecationWarning(msg), stacklevel=2)\n\n    data = []\n    filenames = self.get_filenames(year)\n    connector = NOAAHTTPConnection if use_http else NOAAFTPConnection\n\n    if scale not in (\"C\", \"F\"):\n        msg = 'Scale must be \"C\" (Celsius) or \"F\" (Fahrenheit).'\n        raise ValueError(msg)\n\n    with connector() as conn:\n        for filename in filenames:\n            datastream = conn.read_file_as_bytes(filename)\n            for line in datastream.readlines():\n                date_str = line[15:27].decode(\"utf-8\")\n                dt = pytz.UTC.localize(datetime.strptime(date_str, \"%Y%m%d%H%M\"))  # noqa: DTZ007\n                wind_dir = int(line[60:63]) if line[60:63].decode(\"utf-8\") != \"999\" else float(\"nan\")\n                wind_speed = float(line[65:69]) / 10.0 if line[65:69].decode(\"utf-8\") != \"9999\" else float(\"nan\")\n                tempC = _parse_temp(line[87:92])\n                dewC = _parse_temp(line[93:98])\n                data.append([dt, wind_dir, wind_speed, tempC, dewC])\n\n    timestamps, wind_dirs, wind_speeds, temps, dews = zip(*sorted(data), strict=True)\n    ts = pd.DataFrame(\n        {\"wind_dir\": wind_dirs, \"wind_speed\": wind_speeds, \"tempC\": temps, \"dewC\": dews}, index=timestamps\n    )\n\n    if scale == \"F\":\n        ts[\"tempF\"] = ts[\"tempC\"] * 1.8 + 32\n        ts[\"dewF\"] = ts[\"dewC\"] * 1.8 + 32\n        ts = ts.drop([\"tempC\", \"dewC\"], axis=\"columns\")\n\n    return ts.groupby(ts.index).mean()\n</code></pre>"},{"location":"api/station/#riweather.Station.fetch_temp_data","title":"fetch_temp_data","text":"<pre><code>fetch_temp_data(\n    year=None,\n    value=None,\n    scale=\"C\",\n    period=\"h\",\n    rollup=\"ending\",\n    *,\n    upsample_first=True,\n    use_http=False,\n)\n</code></pre> <p>Retrieve temperature data from the ISD.</p> <p>Warning</p> <p>This has been deprecated and will be removed in a future release. Please consider using <code>riweather.Station.fetch_data</code> instead.</p> <p>Parameters:</p> <ul> <li> <code>year</code>               (<code>int | list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Returned data will be limited to the year specified. If <code>None</code>, data for all years is returned.</p> </li> <li> <code>value</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p><code>\"temperature\"</code> to retrieve the air temperature only, or <code>\"dew_point\"</code> to retrieve the dew point temperature only. <code>None</code> returns both temperatures in a DataFrame.</p> </li> <li> <code>scale</code>               (<code>str</code>, default:                   <code>'C'</code> )           \u2013            <p>Return the value(s) in Celsius (<code>\"C\"</code>, the default) or Fahrenheit (<code>\"F\"</code>).</p> </li> <li> <code>period</code>               (<code>str</code>, default:                   <code>'h'</code> )           \u2013            <p>The time step at which the data will be returned. Defaults to <code>\"h\"</code>, which corresponds to hourly data. Other possible values are <code>\"30min\"</code> for half-hourly data, <code>\"15min\"</code> for quarter-hourly data, and so on. See the Pandas documentation on frequency strings for more details on possible values.</p> </li> <li> <code>rollup</code>               (<code>str</code>, default:                   <code>'ending'</code> )           \u2013            <p>How to align values to the <code>period</code>. Defaults to <code>\"ending\"</code>, meaning that values over the previous time period are averaged.</p> </li> <li> <code>upsample_first</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to upsample the data to the minute level prior to resampling. Usually results in more accurate representations of the true weather data.</p> </li> <li> <code>use_http</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Use NOAA\u2019s HTTP server instead of their FTP server. Set this to <code>True</code> if you are running into issues with FTP.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame | Series</code>           \u2013            <p>Either a DataFrame containing both air temperature and dew point temperature, or, if <code>value</code> was supplied, a Series containing one or the other.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; s = Station(\"720534\")\n&gt;&gt;&gt; print(s.fetch_temp_data(2022).head(2))\n                            wind_dir  wind_speed     tempC      dewC\n2022-01-01 01:00:00+00:00  63.913043    4.197826 -4.328261 -5.539674\n2022-01-01 02:00:00+00:00  17.583333    3.656250 -6.585833 -7.717917\n</code></pre> Source code in <code>src/riweather/stations.py</code> <pre><code>def fetch_temp_data(\n    self,\n    year: int | list[int] | None = None,\n    value: str | None = None,\n    scale: str = \"C\",\n    period: str = \"h\",\n    rollup: str = \"ending\",\n    *,\n    upsample_first: bool = True,\n    use_http: bool = False,\n) -&gt; pd.DataFrame | pd.Series:\n    \"\"\"Retrieve temperature data from the ISD.\n\n    !!! warning\n        This has been deprecated and will be removed in a future release. Please consider using\n        [`riweather.Station.fetch_data`][] instead.\n\n    Args:\n        year: Returned data will be limited to the year specified. If\n            `None`, data for all years is returned.\n        value: `\"temperature\"` to retrieve the air temperature only,\n            or `\"dew_point\"` to retrieve the dew point temperature only.\n            `None` returns both temperatures in a [DataFrame][pandas.DataFrame].\n        scale: Return the value(s) in Celsius (`\"C\"`, the default) or\n            Fahrenheit (`\"F\"`).\n        period: The time step at which the data will be returned. Defaults\n            to `\"h\"`, which corresponds to hourly data. Other possible\n            values are `\"30min\"` for half-hourly data, `\"15min\"`\n            for quarter-hourly data, and so on. See the [Pandas documentation\n            on frequency strings](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects)\n            for more details on possible values.\n        rollup: How to align values to the `period`. Defaults to `\"ending\"`,\n            meaning that values over the previous time period are averaged.\n        upsample_first: Whether to upsample the data to the minute level prior to\n            resampling. Usually results in more accurate representations of the\n            true weather data.\n        use_http: Use NOAA's HTTP server instead of their FTP server. Set\n            this to ``True`` if you are running into issues with FTP.\n\n    Returns:\n        Either a [DataFrame][pandas.DataFrame] containing both air temperature\n            and dew point temperature, or, if `value` was supplied, a\n            [Series][pandas.Series] containing one or the other.\n\n    Examples:\n        &gt;&gt;&gt; s = Station(\"720534\")\n        &gt;&gt;&gt; print(s.fetch_temp_data(2022).head(2))  # doctest: +SKIP\n                                    wind_dir  wind_speed     tempC      dewC\n        2022-01-01 01:00:00+00:00  63.913043    4.197826 -4.328261 -5.539674\n        2022-01-01 02:00:00+00:00  17.583333    3.656250 -6.585833 -7.717917\n    \"\"\"\n    msg = \"fetch_temp_data is deprecated. Please use fetch_data(year, datum='air_temperature') instead.\"\n    warnings.warn(DeprecationWarning(msg), stacklevel=2)\n\n    if value is None:\n        value = \"both\"\n    elif value not in (\"temperature\", \"dew_point\"):\n        msg = 'Value must be \"temperature\" or \"dew_point\"'\n        raise ValueError(msg)\n\n    if rollup not in (\"starting\", \"ending\", \"midpoint\", \"instant\"):\n        msg = \"Invalid rollup\"\n        raise ValueError(msg)\n\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        raw_ts = self.fetch_raw_temp_data(year, scale=scale, use_http=use_http)\n    if rollup == \"starting\":\n        ts = rollup_starting(raw_ts, period, upsample_first=upsample_first)\n    elif rollup == \"ending\":\n        ts = rollup_ending(raw_ts, period, upsample_first=upsample_first)\n    elif rollup == \"midpoint\":\n        ts = rollup_midpoint(raw_ts, period, upsample_first=upsample_first)\n    else:  # rollup == \"instant\"\n        ts = rollup_instant(raw_ts, period, upsample_first=upsample_first)\n\n    if value == \"temperature\":\n        return ts.loc[:, f\"temp{scale}\"]\n    if value == \"dew_point\":\n        return ts.loc[:, f\"dew{scale}\"]\n\n    return ts\n</code></pre>"},{"location":"api/station/#riweather.plot_stations","title":"riweather.plot_stations","text":"<pre><code>plot_stations(lat, lon, ranked_stations, *, n=None, distance_unit='m')\n</code></pre> <p>Plot stations relative to a location.</p> <p>Raises:</p> <ul> <li> <code>ImportError</code>             \u2013            <p>If matplotlib and folium are not installed.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>lat</code>               (<code>float</code>)           \u2013            <p>Site latitude</p> </li> <li> <code>lon</code>               (<code>float</code>)           \u2013            <p>Site longitude</p> </li> <li> <code>ranked_stations</code>               (<code>DataFrame</code>)           \u2013            <p>Ranked stations</p> </li> <li> <code>n</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The <code>n</code> top-ranked stations of <code>ranked_stations</code> will be plotted</p> </li> <li> <code>distance_unit</code>               (<code>str</code>, default:                   <code>'m'</code> )           \u2013            <p>Distance unit to use on the plot. Must be meters (<code>m</code>), kilometers (<code>km</code>), or miles (<code>mi</code>)</p> </li> </ul> Source code in <code>src/riweather/viz.py</code> <pre><code>def plot_stations(\n    lat: float,\n    lon: float,\n    ranked_stations: pd.DataFrame,\n    *,\n    n: int | None = None,\n    distance_unit: str = \"m\",\n):\n    \"\"\"Plot stations relative to a location.\n\n    Raises:\n        ImportError: If [matplotlib][] and\n            [folium](https://python-visualization.github.io/folium/latest) are not installed.\n\n    Args:\n        lat: Site latitude\n        lon: Site longitude\n        ranked_stations: Ranked stations\n        n: The ``n`` top-ranked stations of ``ranked_stations`` will be plotted\n        distance_unit: Distance unit to use on the plot. Must be meters (``m``),\n            kilometers (``km``), or miles (``mi``)\n    \"\"\"\n    try:\n        import matplotlib.pyplot as plt  # noqa\n    except ImportError:\n        msg = \"Plotting stations requires matplotlib\"\n        raise ImportError(msg) from None\n\n    try:\n        import folium\n    except ImportError:\n        msg = \"Plotting stations requires folium\"\n        raise ImportError(msg) from None\n\n    if n is None:\n        n = ranked_stations.shape[0]\n    station_info = ranked_stations.head(n)\n\n    m = folium.Map(location=[lat, lon])\n    folium.Marker([lat, lon], popup=\"Site\").add_to(m)\n    for row in station_info.itertuples():\n        folium.Marker(\n            [row.latitude, row.longitude],\n            popup=row.name,\n            icon=folium.Icon(icon=\"cloud\"),\n        ).add_to(m)\n        folium.PolyLine(\n            [[lat, lon], [row.latitude, row.longitude]],\n            popup=_calculate_distance_labels(row.distance, distance_unit),\n        ).add_to(m)\n\n    return m\n</code></pre>"},{"location":"api/station/#riweather.rank_stations","title":"riweather.rank_stations","text":"<pre><code>rank_stations(lat=None, lon=None, *, year=None, max_distance_m=None, zipcode=None)\n</code></pre> <p>Rank stations by distance to a point.</p> <p>Parameters:</p> <ul> <li> <code>lat</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Site latitude</p> </li> <li> <code>lon</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Site longitude</p> </li> <li> <code>year</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>If specified, only include stations with data for the given year(s).</p> </li> <li> <code>max_distance_m</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>If specified, only include stations within this distance (in meters) from the site.</p> </li> <li> <code>zipcode</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Site zip code. If <code>lat</code> and/or <code>lon</code> are not given and <code>zipcode</code> is, then stations will be ranked according to the distance from the center point of the zip code.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A DataFrame of station information.</p> </li> </ul> Source code in <code>src/riweather/stations.py</code> <pre><code>def rank_stations(\n    lat: float | None = None,\n    lon: float | None = None,\n    *,\n    year: int | None = None,\n    max_distance_m: int | None = None,\n    zipcode: str | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Rank stations by distance to a point.\n\n    Args:\n        lat: Site latitude\n        lon: Site longitude\n        year: If specified, only include stations with data for the given year(s).\n        max_distance_m: If specified, only include stations within this distance\n            (in meters) from the site.\n        zipcode: Site zip code. If ``lat`` and/or ``lon`` are not given and ``zipcode`` is, then\n            stations will be ranked according to the distance from the center point of the zip code.\n\n    Returns:\n        A [DataFrame][pandas.DataFrame] of station information.\n    \"\"\"\n    if lat is None or lon is None:\n        if zipcode is None:\n            msg = \"Either lat and lon must both be provided, or zipcode must be provided.\"\n            raise ValueError(msg)\n        lat, lon = zcta_to_lat_lon(zipcode)\n\n    station_info = {info[\"usaf_id\"]: info for info in _calculate_distances(lat, lon)}\n\n    results = (\n        select(\n            models.Station.usaf_id,\n            models.Station.name,\n            models.FileCount.year,\n            models.FileCount.quality,\n        )\n        .join_from(\n            models.Station,\n            models.FileCount,\n        )\n        .where(models.Station.usaf_id.in_(station_info.keys()))\n    )\n\n    data = {}\n    with MetadataSession() as session:\n        for row in session.execute(results):\n            if row.usaf_id not in data:\n                data[row.usaf_id] = {\n                    **station_info[row.usaf_id],\n                    \"years\": [],\n                    \"quality\": [],\n                }\n\n            data[row.usaf_id][\"years\"].append(row.year)\n            data[row.usaf_id][\"quality\"].append(row.quality)\n\n    data = pd.DataFrame(sorted(data.values(), key=operator.itemgetter(\"distance\"))).set_index(\"usaf_id\")\n\n    if year is not None:\n\n        def _filter_years(x):\n            if isinstance(year, list):\n                return all(y in x for y in year)\n            return year in x\n\n        data = data.loc[data[\"years\"].apply(_filter_years), :]\n\n    if max_distance_m is not None:\n        data = data.loc[data[\"distance\"] &lt;= max_distance_m, :]\n\n    return data\n</code></pre>"},{"location":"api/station/#riweather.select_station","title":"riweather.select_station","text":"<pre><code>select_station(ranked_stations, rank=0)\n</code></pre> <p>Return a Station object out of a ranked set of stations.</p> <p>Parameters:</p> <ul> <li> <code>ranked_stations</code>               (<code>DataFrame</code>)           \u2013            <p>A DataFrame returned by <code>riweather.rank_stations</code>.</p> </li> <li> <code>rank</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Which station to return. Defaults to <code>rank=0</code>, which corresponds to the first (i.e. nearest) station.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Station</code>           \u2013            <p>A <code>Station</code> object.</p> </li> </ul> Source code in <code>src/riweather/stations.py</code> <pre><code>def select_station(ranked_stations: pd.DataFrame, rank: int = 0) -&gt; Station:\n    \"\"\"Return a Station object out of a ranked set of stations.\n\n    Args:\n        ranked_stations: A [DataFrame][pandas.DataFrame] returned by\n            [`riweather.rank_stations`][].\n        rank: Which station to return. Defaults to `rank=0`, which corresponds to\n            the first (i.e. nearest) station.\n\n    Returns:\n        A [`Station`][riweather.Station] object.\n    \"\"\"\n    if len(ranked_stations) &lt;= rank:\n        msg = \"Rank too large, not enough stations\"\n        raise ValueError(msg)\n\n    ranked_stations = ranked_stations.sort_values(\"distance\")\n    station = ranked_stations.iloc[rank]\n    return Station(usaf_id=station.name)\n</code></pre>"},{"location":"api/station/#riweather.zcta_to_lat_lon","title":"riweather.zcta_to_lat_lon","text":"<pre><code>zcta_to_lat_lon(zcta)\n</code></pre> <p>Convert zip code to lat/lon.</p> <p>Parameters:</p> <ul> <li> <code>zcta</code>               (<code>str</code>)           \u2013            <p>Five-digit zip code</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>(float, float)</code>           \u2013            <p>The center point of the ZCTA (Zip Code Tabulation Area).</p> </li> </ul> Source code in <code>src/riweather/stations.py</code> <pre><code>def zcta_to_lat_lon(zcta: str) -&gt; (float, float):\n    \"\"\"Convert zip code to lat/lon.\n\n    Args:\n        zcta: Five-digit zip code\n\n    Returns:\n        The center point of the ZCTA (Zip Code Tabulation Area).\n    \"\"\"\n    with MetadataSession() as session:\n        zcta = session.scalars(select(models.Zcta).where(models.Zcta.zip == zcta)).first()\n\n    return zcta.latitude, zcta.longitude\n</code></pre>"}]}