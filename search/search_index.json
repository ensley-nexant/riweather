{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"riweather \u00b6 riweather makes acquiring weather data easier. At its core, it is little more than a wrapper around NOAA\u2019s Integrated Surface Database (ISD) , which provides hourly surface observations from data sources around the world. With riweather , you can locate the nearest suitable weather station to a certain geographical location and fetch data from that station for one year or several years. You can opt to retrieve the raw observations, which sometimes occur at irregular intervals, or you can let riweather do some interpolating and resampling to fit the observations to a regular time interval of your choosing. Either way, the data is returned in the form of a Pandas DataFrame or Series so that you can easily incorporate it into the rest of your analysis pipeline. Move to the next page for installation instructions, and then see it in action on the Getting Started page .","title":"Home"},{"location":"#riweather","text":"riweather makes acquiring weather data easier. At its core, it is little more than a wrapper around NOAA\u2019s Integrated Surface Database (ISD) , which provides hourly surface observations from data sources around the world. With riweather , you can locate the nearest suitable weather station to a certain geographical location and fetch data from that station for one year or several years. You can opt to retrieve the raw observations, which sometimes occur at irregular intervals, or you can let riweather do some interpolating and resampling to fit the observations to a regular time interval of your choosing. Either way, the data is returned in the form of a Pandas DataFrame or Series so that you can easily incorporate it into the rest of your analysis pipeline. Move to the next page for installation instructions, and then see it in action on the Getting Started page .","title":"riweather"},{"location":"cli/","text":"Command Line Interface \u00b6 riweather uses a small database to keep track of the weather stations that exist in NOAA\u2019s Integrated Surface Database (ISD) , as well as the years for which there is data at each station. The command line interface lets you rebuild this database from scratch, straight from sources present on the ISD server itself. It\u2019s a good idea to do this periodically because NOAA updates the ISD regularly, and the database in riweather will eventually get out of date as new years and/or weather stations are added. Completely rebuilding the database requires two steps. First, riweather must download a few files from the Internet. These files are: isd-history.csv , containing information about each weather station, including ID, name, elevation, and location. isd-inventory.csv , which records the number of weather observations per station and per year. cb_2020_us_county_500k.zip and cb_2020_us_zcta520_500k.zip , which are US Census shapefiles describing the boundaries of counties and Zip Code Tabulation Areas (ZCTAs) , respectively, in the United States. These files are downloaded to a directory on your computer that you specify when you run riweather download-metadata . The second step is to provide this same directory to riweather rebuild-db . The files will be read and assembled into a SQLite database, also located on your computer, which the package can then use to fetch station information and the like. Example \u00b6 To rebuild the database, first run riweather download-metadata -d tmp_riweather_data This will create a directory named tmp_riweather_data and download the files into it. Next, run riweather rebuild-db -s tmp_riweather_data This could take around 10 minutes to run, so please be patient. Once it finishes, you can delete the tmp_riweather_data folder if you\u2019d like \u2013 those files are no longer needed at this point. CLI Reference \u00b6 riweather \u00b6 Riweather makes grabbing weather data easier. Usage: riweather [OPTIONS] COMMAND [ARGS]... Options: --version Show the version and exit. --help Show this message and exit. download-metadata \u00b6 Download weather station and US geography metadata. Pulls files from the Internet that are necessary to (re)build the riweather metadata database. Usage: riweather download-metadata [OPTIONS] Options: -d, --dst DIRECTORY Directory where the data will be stored. [required] --help Show this message and exit. rebuild-db \u00b6 Drop and recreate all tables in the metadata database. Usage: riweather rebuild-db [OPTIONS] Options: -s, --src DIRECTORY Directory where the data is stored. [required] --help Show this message and exit.","title":"Command Line Interface"},{"location":"cli/#command-line-interface","text":"riweather uses a small database to keep track of the weather stations that exist in NOAA\u2019s Integrated Surface Database (ISD) , as well as the years for which there is data at each station. The command line interface lets you rebuild this database from scratch, straight from sources present on the ISD server itself. It\u2019s a good idea to do this periodically because NOAA updates the ISD regularly, and the database in riweather will eventually get out of date as new years and/or weather stations are added. Completely rebuilding the database requires two steps. First, riweather must download a few files from the Internet. These files are: isd-history.csv , containing information about each weather station, including ID, name, elevation, and location. isd-inventory.csv , which records the number of weather observations per station and per year. cb_2020_us_county_500k.zip and cb_2020_us_zcta520_500k.zip , which are US Census shapefiles describing the boundaries of counties and Zip Code Tabulation Areas (ZCTAs) , respectively, in the United States. These files are downloaded to a directory on your computer that you specify when you run riweather download-metadata . The second step is to provide this same directory to riweather rebuild-db . The files will be read and assembled into a SQLite database, also located on your computer, which the package can then use to fetch station information and the like.","title":"Command Line Interface"},{"location":"cli/#example","text":"To rebuild the database, first run riweather download-metadata -d tmp_riweather_data This will create a directory named tmp_riweather_data and download the files into it. Next, run riweather rebuild-db -s tmp_riweather_data This could take around 10 minutes to run, so please be patient. Once it finishes, you can delete the tmp_riweather_data folder if you\u2019d like \u2013 those files are no longer needed at this point.","title":"Example"},{"location":"cli/#cli-reference","text":"","title":"CLI Reference"},{"location":"cli/#riweather","text":"Riweather makes grabbing weather data easier. Usage: riweather [OPTIONS] COMMAND [ARGS]... Options: --version Show the version and exit. --help Show this message and exit.","title":"riweather"},{"location":"cli/#download-metadata","text":"Download weather station and US geography metadata. Pulls files from the Internet that are necessary to (re)build the riweather metadata database. Usage: riweather download-metadata [OPTIONS] Options: -d, --dst DIRECTORY Directory where the data will be stored. [required] --help Show this message and exit.","title":"download-metadata"},{"location":"cli/#rebuild-db","text":"Drop and recreate all tables in the metadata database. Usage: riweather rebuild-db [OPTIONS] Options: -s, --src DIRECTORY Directory where the data is stored. [required] --help Show this message and exit.","title":"rebuild-db"},{"location":"data_resampling/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Data Resampling: An Introduction \u00b6 Often, the reason we need temperature data is to explore the relationship between weather and energy use for a particular building, home, or collection of homes. To quantify this relationship, we need both temperature and energy observations to be on the same time scale - whether that is hourly, half-hourly, etc. Unfortunately, however, readings from weather stations aren\u2019t always available at the particular time scale of your meter readings, and indeed, they aren\u2019t even necessarily at regular intervals at all (the NOAA Integrated Surface Dataset has some stations that sometimes emit data every two minutes and sometimes every twenty minutes, for example). riweather has some tools to ease the process of aligning temperature data to a certain time scale. It builds on top of the resampling functionality of Pandas . This tutorial illustrates the different options at your disposal, so that you can handle the alignment exactly how you need to. import matplotlib.pyplot as plt import pandas as pd import riweather % matplotlib inline Resampling strategies on a toy example \u00b6 Suppose we have the following ten weather observations. They occur twenty minutes apart, at 15, 35, and 55 minutes past the hour. temps = pd . Series ( [ 0 , 9 , 3 , 1 , 2 , 5 , 8 , 6 , 4 , 7 ], index = pd . date_range ( \"2023-01-01 00:15\" , periods = 10 , freq = \"20T\" ), name = \"tempC\" , ) temps 2023-01-01 00:15:00 0 2023-01-01 00:35:00 9 2023-01-01 00:55:00 3 2023-01-01 01:15:00 1 2023-01-01 01:35:00 2 2023-01-01 01:55:00 5 2023-01-01 02:15:00 8 2023-01-01 02:35:00 6 2023-01-01 02:55:00 4 2023-01-01 03:15:00 7 Freq: 20T, Name: tempC, dtype: int64 def plot_temps ( datasets , labels , raw_idx = 0 ): import matplotlib.dates as mdates fig , ax = plt . subplots ( figsize = ( 12 , 4 )) fig . suptitle ( \"Temperature resampling\" ) for i , ( d , l ) in enumerate ( zip ( datasets , labels , strict = True )): if i == raw_idx : ax . plot ( d , \"D\" , color = \"black\" , alpha = 0.2 , label = l ) else : ax . plot ( d , \"x-\" , label = l ) ax . xaxis . set_major_formatter ( mdates . DateFormatter ( \"%I:%M %p\" )) ax . set_ylabel ( \"Temperature (C)\" ) _ = ax . legend () plt . show () datasets = [ temps ] labels = [ \"Actual observations\" ] plot_temps ( datasets , labels ) The four rollup_*() functions \u00b6 We need to align these temperatures to a dataset of smart meter readings that occur at the top of every hour. How can we do this? One option is to take the average of all readings over the previous hour. So, for 1 AM, the previous hour\u2019s readings were 0, 9, and 3 degrees, and the average is 4. With riweather we can do this with rollup_ending() . The word \u201cending\u201d in the name means that we are calculating \u201chour-ending\u201d values. Because meter readings are typically collected as hour-ending values as well, rollup_ending() is the default behavior of the all-in-one fetching and resampling method Station.fetch_temp_data() . temps_ending = riweather . rollup_ending ( temps , \"H\" , upsample_first = False ) temps_ending 2023-01-01 01:00:00 4.000000 2023-01-01 02:00:00 2.666667 2023-01-01 03:00:00 6.000000 2023-01-01 04:00:00 7.000000 Freq: H, Name: tempC, dtype: float64 datasets . append ( temps_ending ) labels . append ( \"Hourly resampling, hour-ending\" ) plot_temps ( datasets , labels ) You can get hour- starting values instead with rollup_starting() . Notice that the first three readings are still averaged together, but the timestamp assigned to the result is midnight (the start of the hour), instead of 1 AM. temps_starting = riweather . rollup_starting ( temps , \"H\" , upsample_first = False ) temps_starting 2023-01-01 00:00:00 4.000000 2023-01-01 01:00:00 2.666667 2023-01-01 02:00:00 6.000000 2023-01-01 03:00:00 7.000000 Freq: H, Name: tempC, dtype: float64 datasets . append ( temps_starting ) labels . append ( \"Hourly resampling, hour-starting\" ) plot_temps ( datasets , labels ) Instead of hour-ending or hour-starting values, you might want the range over which the average is taken to extend both forward and backward. Using rollup_midpoint() , the value at 1 AM will be the average over all data between 12:30 and 1:30 AM. temps_midpoint = riweather . rollup_midpoint ( temps , \"H\" , upsample_first = False ) temps_midpoint 2023-01-01 00:00:00 0.000000 2023-01-01 01:00:00 4.333333 2023-01-01 02:00:00 5.000000 2023-01-01 03:00:00 5.666667 Freq: H, Name: tempC, dtype: float64 datasets . append ( temps_midpoint ) labels . append ( \"Hourly resampling, midpoint\" ) plot_temps ( datasets , labels ) Finally, rollup_instant() does not do any averaging at all. Instead, the value for a certain hour will simply be the first actual data point during that hour. temps_instant = riweather . rollup_instant ( temps , \"H\" , upsample_first = False ) temps_instant 2023-01-01 00:00:00 0 2023-01-01 01:00:00 1 2023-01-01 02:00:00 8 2023-01-01 03:00:00 7 Freq: H, Name: tempC, dtype: int64 datasets . append ( temps_instant ) labels . append ( \"Hourly resampling, instant\" ) plot_temps ( datasets , labels ) Going beyond hourly intervals \u00b6 Every example of the rolling_*() functions so far has specified \"H\" for the second argument. This is a frequency string from Pandas. You can pass any frequency string to get data resampled at different intervals - see the link for more information on how to use the strings. As another example, we could resample our data to get half-hourly intervals: temps_30min_starting = riweather . rollup_starting ( temps , \"30T\" , upsample_first = False ) temps_30min_ending = riweather . rollup_ending ( temps , \"30T\" , upsample_first = False ) datasets = [ temps , temps_30min_starting , temps_30min_ending , ] labels = [ \"Actual observations\" , \"Half-hourly resampling, hour-starting\" , \"Half-hourly resampling, hour-ending\" , ] plot_temps ( datasets , labels ) Upsampling before resampling \u00b6 So far, we have used all of the rollup functions with the parameter upsample_first=False . With this option set, the resampling is done based on the raw values and the raw values only - so, for example, the hour-ending rollup value at 1 AM is precisely the average of all raw values that occurred between 12 AM and 1 AM. This isn\u2019t always the most accurate way to arrive at a single representative value for the entire hour (or half-hour, or whatever the desired time interval is). Consider the following temperatures: temps2 = pd . Series ( [ 1 , 2 , 10 ], index = pd . date_range ( \"2023-01-01 00:01\" , \"2023-01-01 01:05\" , freq = \"32T\" ), ) temps2 2023-01-01 00:01:00 1 2023-01-01 00:33:00 2 2023-01-01 01:05:00 10 Freq: 32T, dtype: int64 There are two observations between 12 AM and 1 AM: 1 degree at 12:01 and 2 degrees at 12:33. If we were to simply take the average in our hour-ending resampling procedure, we would end up with a value of 1.5 degrees at 1 AM. riweather . rollup_ending ( temps2 , \"H\" , upsample_first = False ) 2023-01-01 01:00:00 1.5 2023-01-01 02:00:00 10.0 Freq: H, dtype: float64 However, we can see that the temperature rose to 10 degrees by 1:05, so it\u2019s safe to say there were some higher temperatures in the second half of the 12 AM hour that were not captured by averaging the two observations we had available, and so 1.5 degrees is likely an underestimate of the average temperature over that period. We can address this problem by first upsampling the observations before resampling them. Upsampling means taking data from one time interval to a finer-grained time interval. In this case, we perform linear interpolation to take the data up to the minute level. This allows us to better capture changes in temperature. You can perform the upsampling step on its own with riweather.upsample() : temps2_upsampled = riweather . upsample ( temps2 , \"T\" ) temps2_upsampled 2023-01-01 00:01:00 1.00000 2023-01-01 00:02:00 1.03125 2023-01-01 00:03:00 1.06250 2023-01-01 00:04:00 1.09375 2023-01-01 00:05:00 1.12500 ... 2023-01-01 01:01:00 9.00000 2023-01-01 01:02:00 9.25000 2023-01-01 01:03:00 9.50000 2023-01-01 01:04:00 9.75000 2023-01-01 01:05:00 10.00000 Freq: T, Length: 65, dtype: float64 plot_temps ([ temps2 , temps2_upsampled ], [ \"Actual\" , \"Upsampled\" ]) In the rollup functions, you can perform the upsampling and resampling all in one step by passing upsample_first=True (this is the default, so you can also just omit it). riweather . rollup_ending ( temps2 , \"H\" ) 2023-01-01 01:00:00 3.3 2023-01-01 02:00:00 9.5 Freq: H, dtype: float64 The resampled 1 AM value is now 3.3 degrees, up from 1.5 in the other approach. Going back to the first toy example, let\u2019s observe the difference in hour-ending values with and without the initial upsampling: temps_ending_upsampled = riweather . rollup_ending ( temps , \"H\" , upsample_first = True ) temps_ending_not_upsampled = riweather . rollup_ending ( temps , \"H\" , upsample_first = False ) datasets = [ temps , temps_ending_upsampled , temps_ending_not_upsampled , ] labels = [ \"Actual observations\" , \"Hour-ending, upsampling\" , \"Hour-ending, no upsampling\" , ] plot_temps ( datasets , labels ) Fetching, upsampling, and resampling from a Station \u00b6 When fetching temperature data from the ISD, you can perform all of the resampling in a single step by passing the appropriate parameters to Station.fetch_temp_data() . s = riweather . Station ( \"720534\" ) temps = s . fetch_temp_data ( 2022 , \"temperature\" , \"F\" , period = \"H\" , rollup = \"ending\" , upsample_first = True ) temps . head () 2022-01-01 01:00:00+00:00 24.20913 2022-01-01 02:00:00+00:00 20.14550 2022-01-01 03:00:00+00:00 17.93000 2022-01-01 04:00:00+00:00 16.75850 2022-01-01 05:00:00+00:00 16.36475 Freq: H, Name: tempF, dtype: float64 Customizing the resampling process \u00b6 When used in this way, Station.fetch_temp_data() performs three steps: Fetching the raw data from the ISD Upsample to minute-level (if desired) Resample to the given time interval Each of these steps is exposed by the riweather API as separate functions, so if you want to directly manipulate the data with Pandas, you may store the intermediate datasets and use them however you want. To recreate the exact steps performed in fetch_temp_data() : temps_raw = s . fetch_raw_temp_data ( 2022 , \"F\" )[ \"tempF\" ] temps_upsampled = riweather . upsample ( temps_raw , \"T\" ) temps_resampled = riweather . rollup_ending ( temps_upsampled , upsample_first = False ) temps_resampled . head () 2022-01-01 01:00:00+00:00 24.20913 2022-01-01 02:00:00+00:00 20.14550 2022-01-01 03:00:00+00:00 17.93000 2022-01-01 04:00:00+00:00 16.75850 2022-01-01 05:00:00+00:00 16.36475 Freq: H, Name: tempF, dtype: float64","title":"Data Resampling Introduction"},{"location":"data_resampling/#data-resampling-an-introduction","text":"Often, the reason we need temperature data is to explore the relationship between weather and energy use for a particular building, home, or collection of homes. To quantify this relationship, we need both temperature and energy observations to be on the same time scale - whether that is hourly, half-hourly, etc. Unfortunately, however, readings from weather stations aren\u2019t always available at the particular time scale of your meter readings, and indeed, they aren\u2019t even necessarily at regular intervals at all (the NOAA Integrated Surface Dataset has some stations that sometimes emit data every two minutes and sometimes every twenty minutes, for example). riweather has some tools to ease the process of aligning temperature data to a certain time scale. It builds on top of the resampling functionality of Pandas . This tutorial illustrates the different options at your disposal, so that you can handle the alignment exactly how you need to. import matplotlib.pyplot as plt import pandas as pd import riweather % matplotlib inline","title":"Data Resampling: An Introduction"},{"location":"data_resampling/#resampling-strategies-on-a-toy-example","text":"Suppose we have the following ten weather observations. They occur twenty minutes apart, at 15, 35, and 55 minutes past the hour. temps = pd . Series ( [ 0 , 9 , 3 , 1 , 2 , 5 , 8 , 6 , 4 , 7 ], index = pd . date_range ( \"2023-01-01 00:15\" , periods = 10 , freq = \"20T\" ), name = \"tempC\" , ) temps 2023-01-01 00:15:00 0 2023-01-01 00:35:00 9 2023-01-01 00:55:00 3 2023-01-01 01:15:00 1 2023-01-01 01:35:00 2 2023-01-01 01:55:00 5 2023-01-01 02:15:00 8 2023-01-01 02:35:00 6 2023-01-01 02:55:00 4 2023-01-01 03:15:00 7 Freq: 20T, Name: tempC, dtype: int64 def plot_temps ( datasets , labels , raw_idx = 0 ): import matplotlib.dates as mdates fig , ax = plt . subplots ( figsize = ( 12 , 4 )) fig . suptitle ( \"Temperature resampling\" ) for i , ( d , l ) in enumerate ( zip ( datasets , labels , strict = True )): if i == raw_idx : ax . plot ( d , \"D\" , color = \"black\" , alpha = 0.2 , label = l ) else : ax . plot ( d , \"x-\" , label = l ) ax . xaxis . set_major_formatter ( mdates . DateFormatter ( \"%I:%M %p\" )) ax . set_ylabel ( \"Temperature (C)\" ) _ = ax . legend () plt . show () datasets = [ temps ] labels = [ \"Actual observations\" ] plot_temps ( datasets , labels )","title":"Resampling strategies on a toy example"},{"location":"data_resampling/#the-four-rollup_-functions","text":"We need to align these temperatures to a dataset of smart meter readings that occur at the top of every hour. How can we do this? One option is to take the average of all readings over the previous hour. So, for 1 AM, the previous hour\u2019s readings were 0, 9, and 3 degrees, and the average is 4. With riweather we can do this with rollup_ending() . The word \u201cending\u201d in the name means that we are calculating \u201chour-ending\u201d values. Because meter readings are typically collected as hour-ending values as well, rollup_ending() is the default behavior of the all-in-one fetching and resampling method Station.fetch_temp_data() . temps_ending = riweather . rollup_ending ( temps , \"H\" , upsample_first = False ) temps_ending 2023-01-01 01:00:00 4.000000 2023-01-01 02:00:00 2.666667 2023-01-01 03:00:00 6.000000 2023-01-01 04:00:00 7.000000 Freq: H, Name: tempC, dtype: float64 datasets . append ( temps_ending ) labels . append ( \"Hourly resampling, hour-ending\" ) plot_temps ( datasets , labels ) You can get hour- starting values instead with rollup_starting() . Notice that the first three readings are still averaged together, but the timestamp assigned to the result is midnight (the start of the hour), instead of 1 AM. temps_starting = riweather . rollup_starting ( temps , \"H\" , upsample_first = False ) temps_starting 2023-01-01 00:00:00 4.000000 2023-01-01 01:00:00 2.666667 2023-01-01 02:00:00 6.000000 2023-01-01 03:00:00 7.000000 Freq: H, Name: tempC, dtype: float64 datasets . append ( temps_starting ) labels . append ( \"Hourly resampling, hour-starting\" ) plot_temps ( datasets , labels ) Instead of hour-ending or hour-starting values, you might want the range over which the average is taken to extend both forward and backward. Using rollup_midpoint() , the value at 1 AM will be the average over all data between 12:30 and 1:30 AM. temps_midpoint = riweather . rollup_midpoint ( temps , \"H\" , upsample_first = False ) temps_midpoint 2023-01-01 00:00:00 0.000000 2023-01-01 01:00:00 4.333333 2023-01-01 02:00:00 5.000000 2023-01-01 03:00:00 5.666667 Freq: H, Name: tempC, dtype: float64 datasets . append ( temps_midpoint ) labels . append ( \"Hourly resampling, midpoint\" ) plot_temps ( datasets , labels ) Finally, rollup_instant() does not do any averaging at all. Instead, the value for a certain hour will simply be the first actual data point during that hour. temps_instant = riweather . rollup_instant ( temps , \"H\" , upsample_first = False ) temps_instant 2023-01-01 00:00:00 0 2023-01-01 01:00:00 1 2023-01-01 02:00:00 8 2023-01-01 03:00:00 7 Freq: H, Name: tempC, dtype: int64 datasets . append ( temps_instant ) labels . append ( \"Hourly resampling, instant\" ) plot_temps ( datasets , labels )","title":"The four rollup_*() functions"},{"location":"data_resampling/#going-beyond-hourly-intervals","text":"Every example of the rolling_*() functions so far has specified \"H\" for the second argument. This is a frequency string from Pandas. You can pass any frequency string to get data resampled at different intervals - see the link for more information on how to use the strings. As another example, we could resample our data to get half-hourly intervals: temps_30min_starting = riweather . rollup_starting ( temps , \"30T\" , upsample_first = False ) temps_30min_ending = riweather . rollup_ending ( temps , \"30T\" , upsample_first = False ) datasets = [ temps , temps_30min_starting , temps_30min_ending , ] labels = [ \"Actual observations\" , \"Half-hourly resampling, hour-starting\" , \"Half-hourly resampling, hour-ending\" , ] plot_temps ( datasets , labels )","title":"Going beyond hourly intervals"},{"location":"data_resampling/#upsampling-before-resampling","text":"So far, we have used all of the rollup functions with the parameter upsample_first=False . With this option set, the resampling is done based on the raw values and the raw values only - so, for example, the hour-ending rollup value at 1 AM is precisely the average of all raw values that occurred between 12 AM and 1 AM. This isn\u2019t always the most accurate way to arrive at a single representative value for the entire hour (or half-hour, or whatever the desired time interval is). Consider the following temperatures: temps2 = pd . Series ( [ 1 , 2 , 10 ], index = pd . date_range ( \"2023-01-01 00:01\" , \"2023-01-01 01:05\" , freq = \"32T\" ), ) temps2 2023-01-01 00:01:00 1 2023-01-01 00:33:00 2 2023-01-01 01:05:00 10 Freq: 32T, dtype: int64 There are two observations between 12 AM and 1 AM: 1 degree at 12:01 and 2 degrees at 12:33. If we were to simply take the average in our hour-ending resampling procedure, we would end up with a value of 1.5 degrees at 1 AM. riweather . rollup_ending ( temps2 , \"H\" , upsample_first = False ) 2023-01-01 01:00:00 1.5 2023-01-01 02:00:00 10.0 Freq: H, dtype: float64 However, we can see that the temperature rose to 10 degrees by 1:05, so it\u2019s safe to say there were some higher temperatures in the second half of the 12 AM hour that were not captured by averaging the two observations we had available, and so 1.5 degrees is likely an underestimate of the average temperature over that period. We can address this problem by first upsampling the observations before resampling them. Upsampling means taking data from one time interval to a finer-grained time interval. In this case, we perform linear interpolation to take the data up to the minute level. This allows us to better capture changes in temperature. You can perform the upsampling step on its own with riweather.upsample() : temps2_upsampled = riweather . upsample ( temps2 , \"T\" ) temps2_upsampled 2023-01-01 00:01:00 1.00000 2023-01-01 00:02:00 1.03125 2023-01-01 00:03:00 1.06250 2023-01-01 00:04:00 1.09375 2023-01-01 00:05:00 1.12500 ... 2023-01-01 01:01:00 9.00000 2023-01-01 01:02:00 9.25000 2023-01-01 01:03:00 9.50000 2023-01-01 01:04:00 9.75000 2023-01-01 01:05:00 10.00000 Freq: T, Length: 65, dtype: float64 plot_temps ([ temps2 , temps2_upsampled ], [ \"Actual\" , \"Upsampled\" ]) In the rollup functions, you can perform the upsampling and resampling all in one step by passing upsample_first=True (this is the default, so you can also just omit it). riweather . rollup_ending ( temps2 , \"H\" ) 2023-01-01 01:00:00 3.3 2023-01-01 02:00:00 9.5 Freq: H, dtype: float64 The resampled 1 AM value is now 3.3 degrees, up from 1.5 in the other approach. Going back to the first toy example, let\u2019s observe the difference in hour-ending values with and without the initial upsampling: temps_ending_upsampled = riweather . rollup_ending ( temps , \"H\" , upsample_first = True ) temps_ending_not_upsampled = riweather . rollup_ending ( temps , \"H\" , upsample_first = False ) datasets = [ temps , temps_ending_upsampled , temps_ending_not_upsampled , ] labels = [ \"Actual observations\" , \"Hour-ending, upsampling\" , \"Hour-ending, no upsampling\" , ] plot_temps ( datasets , labels )","title":"Upsampling before resampling"},{"location":"data_resampling/#fetching-upsampling-and-resampling-from-a-station","text":"When fetching temperature data from the ISD, you can perform all of the resampling in a single step by passing the appropriate parameters to Station.fetch_temp_data() . s = riweather . Station ( \"720534\" ) temps = s . fetch_temp_data ( 2022 , \"temperature\" , \"F\" , period = \"H\" , rollup = \"ending\" , upsample_first = True ) temps . head () 2022-01-01 01:00:00+00:00 24.20913 2022-01-01 02:00:00+00:00 20.14550 2022-01-01 03:00:00+00:00 17.93000 2022-01-01 04:00:00+00:00 16.75850 2022-01-01 05:00:00+00:00 16.36475 Freq: H, Name: tempF, dtype: float64","title":"Fetching, upsampling, and resampling from a Station"},{"location":"data_resampling/#customizing-the-resampling-process","text":"When used in this way, Station.fetch_temp_data() performs three steps: Fetching the raw data from the ISD Upsample to minute-level (if desired) Resample to the given time interval Each of these steps is exposed by the riweather API as separate functions, so if you want to directly manipulate the data with Pandas, you may store the intermediate datasets and use them however you want. To recreate the exact steps performed in fetch_temp_data() : temps_raw = s . fetch_raw_temp_data ( 2022 , \"F\" )[ \"tempF\" ] temps_upsampled = riweather . upsample ( temps_raw , \"T\" ) temps_resampled = riweather . rollup_ending ( temps_upsampled , upsample_first = False ) temps_resampled . head () 2022-01-01 01:00:00+00:00 24.20913 2022-01-01 02:00:00+00:00 20.14550 2022-01-01 03:00:00+00:00 17.93000 2022-01-01 04:00:00+00:00 16.75850 2022-01-01 05:00:00+00:00 16.36475 Freq: H, Name: tempF, dtype: float64","title":"Customizing the resampling process"},{"location":"getting_started/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Getting Started With riweather \u00b6 import matplotlib.pyplot as plt import riweather % matplotlib inline Suppose you need weather data at a certain site. To list all weather stations in order of their distance to that site, use riweather.rank_stations() . my_lat , my_lon = 39.98 , - 105.13 ranked_stations = riweather . rank_stations ( my_lat , my_lon ) print ( \"Number of stations returned:\" , ranked_stations . shape [ 0 ]) ranked_stations . head () Number of stations returned: 2851 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name distance latitude longitude years quality usaf_id 720534 ERIE MUNICIPAL AIRPORT 7971.794695 40.017 -105.050 [2014, 2015, 2016, 2017, 2018, 2019, 2020, 202... [low, high, high, high, high, high, high, high... 724699 ATCT ROCKY MOUNTAIN METRO 8951.899139 39.900 -105.117 [2006, 2007, 2008, 2009, 2010, 2011, 2012, 201... [medium, medium, medium, medium, high, high, h... 720533 BOULDER MUNICIPAL AIRPORT 9477.070760 40.033 -105.217 [2010, 2011, 2012, 2013, 2014, 2015, 2016, 201... [medium, high, high, high, high, high, high, h... 720538 VANCE BRAND AIRPORT 21002.247034 40.167 -105.167 [2010, 2011, 2012, 2013, 2014, 2015, 2016, 201... [low, high, high, high, high, high, high, high... 725650 DENVER INTERNATIONAL AIRPORT 43134.270016 39.847 -104.656 [2005, 2006, 2007, 2008, 2009, 2010, 2011, 201... [high, high, high, high, high, high, high, hig... This gives us the name and USAF identifiers of all ISD weather stations in the United States, along with their latitudes and longitudes and their distances (in meters) to the target site. The \u201cyears\u201d column is a list of years for which there is available weather data from that station. The \u201cquality\u201d column contains the quality of the data file for the corresponding year\u2014this is based on the number of observations in the file. You probably don\u2019t want all three thousand weather stations that are returned, so let\u2019s be more efficient and limit our search to stations that have data for 2022 and stations that are within 20 km. ranked_stations = riweather . rank_stations ( my_lat , my_lon , year = 2022 , max_distance_m = 20000 , ) ranked_stations .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name distance latitude longitude years quality usaf_id 720534 ERIE MUNICIPAL AIRPORT 7971.794695 40.017 -105.050 [2014, 2015, 2016, 2017, 2018, 2019, 2020, 202... [low, high, high, high, high, high, high, high... 724699 ATCT ROCKY MOUNTAIN METRO 8951.899139 39.900 -105.117 [2006, 2007, 2008, 2009, 2010, 2011, 2012, 201... [medium, medium, medium, medium, high, high, h... 720533 BOULDER MUNICIPAL AIRPORT 9477.070760 40.033 -105.217 [2010, 2011, 2012, 2013, 2014, 2015, 2016, 201... [medium, high, high, high, high, high, high, h... Select the closest station, Erie Municipal Airport, using riweather.select_station() . station = riweather . select_station ( ranked_stations , rank = 0 ) station Station(\"720534\") Let\u2019s see how complete we can expect the data to be when we pull it by looking at the quality report. station . quality_report () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } usaf_id wban_id year quality jan feb mar apr may jun jul aug sep oct nov dec count n_zero_months 0 720534 00161 2014 low 0 0 0 0 0 0 2191 2172 1869 2240 2160 2174 12806 6 1 720534 00161 2015 high 2232 1981 2226 2117 2244 2035 2232 2233 2084 2217 2151 2232 25984 0 2 720534 00161 2016 high 2240 2094 2239 2168 2255 2147 2203 2129 2173 2211 2164 2150 26173 0 3 720534 00161 2017 high 2143 1961 2213 2163 2061 2167 2204 2095 2172 2198 2888 2242 26507 0 4 720534 00161 2018 high 2219 2033 2272 2198 2523 2191 2292 2388 2125 2298 2217 2284 27040 0 5 720534 00161 2019 high 2279 2084 2255 2286 2432 2288 1780 1810 2088 2226 2169 2239 25936 0 6 720534 00161 2020 high 2056 2093 2234 2167 2232 2145 2096 2026 2161 2187 2160 2202 25759 0 7 720534 00161 2021 high 2227 2027 2245 2159 2232 2174 2168 2243 2098 2235 2145 2208 26161 0 8 720534 00161 2022 high 2237 2020 2152 2049 2232 2168 2250 2241 2160 2231 2169 2187 26096 0 9 720534 00161 2023 high 575 0 0 0 0 0 0 0 0 0 0 0 575 0 The data for 2022 is \"high\" quality, with more than 2,000 observations in each month. Assuming they are evenly spaced, that corresponds to one observation roughly every 20 minutes. Now we can use the Station.fetch_temp_data() method to get temperature data in degrees Fahrenheit. ts = station . fetch_temp_data ( 2022 , value = \"temperature\" , scale = \"F\" ) ts . head () 2022-01-01 00:00:00+00:00 24.2620 2022-01-01 01:00:00+00:00 20.1995 2022-01-01 02:00:00+00:00 17.9525 2022-01-01 03:00:00+00:00 16.7690 2022-01-01 04:00:00+00:00 16.3715 Freq: H, Name: tempF, dtype: float64 It\u2019s important to note that the timestamps are always in UTC . The temperature data is hourly by default, but riweather can resample it to a different frequency as well. ts_30min = station . fetch_temp_data ( 2022 , value = \"temperature\" , scale = \"F\" , period = \"30min\" , ) ts_30min . head () 2022-01-01 00:00:00+00:00 26.0780 2022-01-01 00:30:00+00:00 23.3540 2022-01-01 01:00:00+00:00 21.0470 2022-01-01 01:30:00+00:00 19.3520 2022-01-01 02:00:00+00:00 18.2975 Freq: 30T, Name: tempF, dtype: float64 ts_30min . plot ( title = f \"Air temperature at { station . name . title () } , 2022\" , ylabel = \"Air temperature (degrees F)\" , ) plt . show () We can verify the location of our site and the nearest weather stations by plotting them on a map with riweather.plot_stations() . riweather . plot_stations ( my_lat , my_lon , ranked_stations , distance_unit = \"mi\" ) Make this Notebook Trusted to load map: File -> Trust Notebook Only have a ZIP code for your site and not a precise latitude and longitude? No problem. You can use riweather.zcta_to_lat_lon() to get an approximate location. my_lat , my_lon = riweather . zcta_to_lat_lon ( \"80027\" ) print ( f \" { my_lat : .3f } \" , f \" { my_lon : .3f } \" ) 39.951 -105.164 ranked_stations = riweather . rank_stations ( my_lat , my_lon , max_distance_m = 20000 ) riweather . plot_stations ( my_lat , my_lon , ranked_stations , distance_unit = \"mi\" ) Make this Notebook Trusted to load map: File -> Trust Notebook","title":"Getting Started"},{"location":"getting_started/#getting-started-with-riweather","text":"import matplotlib.pyplot as plt import riweather % matplotlib inline Suppose you need weather data at a certain site. To list all weather stations in order of their distance to that site, use riweather.rank_stations() . my_lat , my_lon = 39.98 , - 105.13 ranked_stations = riweather . rank_stations ( my_lat , my_lon ) print ( \"Number of stations returned:\" , ranked_stations . shape [ 0 ]) ranked_stations . head () Number of stations returned: 2851 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name distance latitude longitude years quality usaf_id 720534 ERIE MUNICIPAL AIRPORT 7971.794695 40.017 -105.050 [2014, 2015, 2016, 2017, 2018, 2019, 2020, 202... [low, high, high, high, high, high, high, high... 724699 ATCT ROCKY MOUNTAIN METRO 8951.899139 39.900 -105.117 [2006, 2007, 2008, 2009, 2010, 2011, 2012, 201... [medium, medium, medium, medium, high, high, h... 720533 BOULDER MUNICIPAL AIRPORT 9477.070760 40.033 -105.217 [2010, 2011, 2012, 2013, 2014, 2015, 2016, 201... [medium, high, high, high, high, high, high, h... 720538 VANCE BRAND AIRPORT 21002.247034 40.167 -105.167 [2010, 2011, 2012, 2013, 2014, 2015, 2016, 201... [low, high, high, high, high, high, high, high... 725650 DENVER INTERNATIONAL AIRPORT 43134.270016 39.847 -104.656 [2005, 2006, 2007, 2008, 2009, 2010, 2011, 201... [high, high, high, high, high, high, high, hig... This gives us the name and USAF identifiers of all ISD weather stations in the United States, along with their latitudes and longitudes and their distances (in meters) to the target site. The \u201cyears\u201d column is a list of years for which there is available weather data from that station. The \u201cquality\u201d column contains the quality of the data file for the corresponding year\u2014this is based on the number of observations in the file. You probably don\u2019t want all three thousand weather stations that are returned, so let\u2019s be more efficient and limit our search to stations that have data for 2022 and stations that are within 20 km. ranked_stations = riweather . rank_stations ( my_lat , my_lon , year = 2022 , max_distance_m = 20000 , ) ranked_stations .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name distance latitude longitude years quality usaf_id 720534 ERIE MUNICIPAL AIRPORT 7971.794695 40.017 -105.050 [2014, 2015, 2016, 2017, 2018, 2019, 2020, 202... [low, high, high, high, high, high, high, high... 724699 ATCT ROCKY MOUNTAIN METRO 8951.899139 39.900 -105.117 [2006, 2007, 2008, 2009, 2010, 2011, 2012, 201... [medium, medium, medium, medium, high, high, h... 720533 BOULDER MUNICIPAL AIRPORT 9477.070760 40.033 -105.217 [2010, 2011, 2012, 2013, 2014, 2015, 2016, 201... [medium, high, high, high, high, high, high, h... Select the closest station, Erie Municipal Airport, using riweather.select_station() . station = riweather . select_station ( ranked_stations , rank = 0 ) station Station(\"720534\") Let\u2019s see how complete we can expect the data to be when we pull it by looking at the quality report. station . quality_report () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } usaf_id wban_id year quality jan feb mar apr may jun jul aug sep oct nov dec count n_zero_months 0 720534 00161 2014 low 0 0 0 0 0 0 2191 2172 1869 2240 2160 2174 12806 6 1 720534 00161 2015 high 2232 1981 2226 2117 2244 2035 2232 2233 2084 2217 2151 2232 25984 0 2 720534 00161 2016 high 2240 2094 2239 2168 2255 2147 2203 2129 2173 2211 2164 2150 26173 0 3 720534 00161 2017 high 2143 1961 2213 2163 2061 2167 2204 2095 2172 2198 2888 2242 26507 0 4 720534 00161 2018 high 2219 2033 2272 2198 2523 2191 2292 2388 2125 2298 2217 2284 27040 0 5 720534 00161 2019 high 2279 2084 2255 2286 2432 2288 1780 1810 2088 2226 2169 2239 25936 0 6 720534 00161 2020 high 2056 2093 2234 2167 2232 2145 2096 2026 2161 2187 2160 2202 25759 0 7 720534 00161 2021 high 2227 2027 2245 2159 2232 2174 2168 2243 2098 2235 2145 2208 26161 0 8 720534 00161 2022 high 2237 2020 2152 2049 2232 2168 2250 2241 2160 2231 2169 2187 26096 0 9 720534 00161 2023 high 575 0 0 0 0 0 0 0 0 0 0 0 575 0 The data for 2022 is \"high\" quality, with more than 2,000 observations in each month. Assuming they are evenly spaced, that corresponds to one observation roughly every 20 minutes. Now we can use the Station.fetch_temp_data() method to get temperature data in degrees Fahrenheit. ts = station . fetch_temp_data ( 2022 , value = \"temperature\" , scale = \"F\" ) ts . head () 2022-01-01 00:00:00+00:00 24.2620 2022-01-01 01:00:00+00:00 20.1995 2022-01-01 02:00:00+00:00 17.9525 2022-01-01 03:00:00+00:00 16.7690 2022-01-01 04:00:00+00:00 16.3715 Freq: H, Name: tempF, dtype: float64 It\u2019s important to note that the timestamps are always in UTC . The temperature data is hourly by default, but riweather can resample it to a different frequency as well. ts_30min = station . fetch_temp_data ( 2022 , value = \"temperature\" , scale = \"F\" , period = \"30min\" , ) ts_30min . head () 2022-01-01 00:00:00+00:00 26.0780 2022-01-01 00:30:00+00:00 23.3540 2022-01-01 01:00:00+00:00 21.0470 2022-01-01 01:30:00+00:00 19.3520 2022-01-01 02:00:00+00:00 18.2975 Freq: 30T, Name: tempF, dtype: float64 ts_30min . plot ( title = f \"Air temperature at { station . name . title () } , 2022\" , ylabel = \"Air temperature (degrees F)\" , ) plt . show () We can verify the location of our site and the nearest weather stations by plotting them on a map with riweather.plot_stations() . riweather . plot_stations ( my_lat , my_lon , ranked_stations , distance_unit = \"mi\" ) Make this Notebook Trusted to load map: File -> Trust Notebook Only have a ZIP code for your site and not a precise latitude and longitude? No problem. You can use riweather.zcta_to_lat_lon() to get an approximate location. my_lat , my_lon = riweather . zcta_to_lat_lon ( \"80027\" ) print ( f \" { my_lat : .3f } \" , f \" { my_lon : .3f } \" ) 39.951 -105.164 ranked_stations = riweather . rank_stations ( my_lat , my_lon , max_distance_m = 20000 ) riweather . plot_stations ( my_lat , my_lon , ranked_stations , distance_unit = \"mi\" ) Make this Notebook Trusted to load map: File -> Trust Notebook","title":"Getting Started With riweather"},{"location":"install/","text":"Installation \u00b6 With pip \u00b6 pip install riweather The basic installation method does not install the packages required for plotting stations with riweather.plot_stations . If you want to make plots, install the optional plots dependencies: pip install riweather [ plots ]","title":"Installation"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#with-pip","text":"pip install riweather The basic installation method does not install the packages required for plotting stations with riweather.plot_stations . If you want to make plots, install the optional plots dependencies: pip install riweather [ plots ]","title":"With pip"},{"location":"reference/","text":"API Reference \u00b6 riweather \u00b6 riweather. Grab publicly available weather data. plot_stations \u00b6 plot_stations ( lat , lon , ranked_stations , * , n = None , distance_unit = \"m\" ) Plot stations relative to a location. Raises: Type Description ImportError If matplotlib and folium are not installed. Parameters: Name Type Description Default lat float Site latitude required lon float Site longitude required ranked_stations pd . DataFrame Ranked stations required n int The n top-ranked stations of ranked_stations will be plotted None distance_unit str Distance unit to use on the plot. Must be meters ( m ), kilometers ( km ), or miles ( mi ) 'm' Source code in riweather/viz.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def plot_stations ( lat : float , lon : float , ranked_stations : pd . DataFrame , * , n : int = None , distance_unit : str = \"m\" , ): \"\"\"Plot stations relative to a location. Raises: ImportError: If [matplotlib][] and [folium](https://python-visualization.github.io/folium/) are not installed. Args: lat: Site latitude lon: Site longitude ranked_stations: Ranked stations n: The ``n`` top-ranked stations of ``ranked_stations`` will be plotted distance_unit: Distance unit to use on the plot. Must be meters (``m``), kilometers (``km``), or miles (``mi``) \"\"\" try : import matplotlib.pyplot as plt # noqa except ImportError : raise ImportError ( \"Plotting stations requires matplotlib\" ) from None try : import folium except ImportError : raise ImportError ( \"Plotting stations requires folium\" ) from None if n is None : n = ranked_stations . shape [ 0 ] station_info = ranked_stations . head ( n ) m = folium . Map ( location = [ lat , lon ]) folium . Marker ([ lat , lon ], popup = \"Site\" ) . add_to ( m ) for row in station_info . itertuples (): folium . Marker ( [ row . latitude , row . longitude ], popup = row . name , icon = folium . Icon ( icon = \"cloud\" ), ) . add_to ( m ) folium . PolyLine ( [[ lat , lon ], [ row . latitude , row . longitude ]], popup = _calculate_distance_labels ( row . distance , distance_unit ), ) . add_to ( m ) return m rank_stations \u00b6 rank_stations ( lat , lon , * , year = None , max_distance_m = None ) Rank stations by distance to a point. Parameters: Name Type Description Default lat float Site latitude required lon float Site longitude required year int If specified, only include stations with data for the given year(s). None max_distance_m int If specified, only include stations within this distance (in meters) from the site. None Returns: Type Description pd . DataFrame A DataFrame of station information. Source code in riweather/stations.py 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 def rank_stations ( lat : float , lon : float , * , year : int = None , max_distance_m : int = None ) -> pd . DataFrame : \"\"\"Rank stations by distance to a point. Args: lat: Site latitude lon: Site longitude year: If specified, only include stations with data for the given year(s). max_distance_m: If specified, only include stations within this distance (in meters) from the site. Returns: A [DataFrame][pandas.DataFrame] of station information. \"\"\" station_info = { info [ \"usaf_id\" ]: info for info in _calculate_distances ( lat , lon )} results = ( select ( models . Station . usaf_id , models . Station . name , models . FileCount . year , models . FileCount . quality , ) . join_from ( models . Station , models . FileCount , ) . where ( models . Station . usaf_id . in_ ( station_info . keys ())) ) data = {} with MetadataSession () as session : for row in session . execute ( results ): if row . usaf_id not in data . keys (): data [ row . usaf_id ] = { ** station_info [ row . usaf_id ], \"years\" : [], \"quality\" : [], } data [ row . usaf_id ][ \"years\" ] . append ( row . year ) data [ row . usaf_id ][ \"quality\" ] . append ( row . quality ) data = pd . DataFrame ( sorted ( data . values (), key = operator . itemgetter ( \"distance\" )) ) . set_index ( \"usaf_id\" ) if year is not None : def _filter_years ( x ): if isinstance ( year , list ): return all ( y in x for y in year ) else : return year in x data = data . loc [ data [ \"years\" ] . apply ( _filter_years ), :] if max_distance_m is not None : data = data . loc [ data [ \"distance\" ] <= max_distance_m , :] return data select_station \u00b6 select_station ( ranked_stations , rank = 0 ) Return a Station object out of a ranked set of stations. Parameters: Name Type Description Default ranked_stations pd . DataFrame A DataFrame returned by [ riweather.rank_stations ]. required rank int Which station to return. Defaults to rank=0 , which corresponds to the first (i.e. nearest) station. 0 Returns: Type Description Station A Station object. Source code in riweather/stations.py 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 def select_station ( ranked_stations : pd . DataFrame , rank : int = 0 ) -> Station : \"\"\"Return a Station object out of a ranked set of stations. Args: ranked_stations: A [DataFrame][pandas.DataFrame] returned by [`riweather.rank_stations`]. rank: Which station to return. Defaults to `rank=0`, which corresponds to the first (i.e. nearest) station. Returns: A [`Station`][riweather.Station] object. \"\"\" if len ( ranked_stations ) <= rank : raise ValueError ( \"Rank too large, not enough stations\" ) ranked_stations = ranked_stations . sort_values ( \"distance\" ) station = ranked_stations . iloc [ rank ] return Station ( usaf_id = station . name ) zcta_to_lat_lon \u00b6 zcta_to_lat_lon ( zcta ) Convert zip code to lat/lon. Parameters: Name Type Description Default zcta str Five-digit zip code required Returns: Type Description float , float The center point of the ZCTA (Zip Code Tabulation Area). Source code in riweather/stations.py 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 def zcta_to_lat_lon ( zcta : str ) -> ( float , float ): \"\"\"Convert zip code to lat/lon. Args: zcta: Five-digit zip code Returns: The center point of the ZCTA (Zip Code Tabulation Area). \"\"\" with MetadataSession () as session : zcta = session . scalars ( select ( models . Zcta ) . where ( models . Zcta . zip == zcta ) ) . first () return zcta . latitude , zcta . longitude Station \u00b6 Station ( usaf_id , load_metadata_on_init = True ) ISD Station object. Parameters: Name Type Description Default usaf_id str USAF identifier required load_metadata_on_init bool If True , station metadata will be retrieved from the local data store and loaded into the object as properties. True Examples: >>> s = Station ( \"720534\" ) >>> print ( s . name , s . latitude , s . longitude ) ERIE MUNICIPAL AIRPORT 40.017 -105.05 Source code in riweather/stations.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def __init__ ( self , usaf_id : str , load_metadata_on_init : bool = True ): \"\"\"ISD Station object. Args: usaf_id: USAF identifier load_metadata_on_init: If `True`, station metadata will be retrieved from the local data store and loaded into the object as properties. Examples: >>> s = Station(\"720534\") >>> print(s.name, s.latitude, s.longitude) ERIE MUNICIPAL AIRPORT 40.017 -105.05 \"\"\" self . usaf_id = usaf_id if load_metadata_on_init : self . _station = self . _load_metadata () else : self . _station = {} elevation property \u00b6 elevation : float Elevation of the station, in meters. icao_code property \u00b6 icao_code : str ICAO airport code. latitude property \u00b6 latitude : float Station latitude. longitude property \u00b6 longitude : float Station longitude. name property \u00b6 name : str Station name. recent_wban_id property \u00b6 recent_wban_id : str Most recent WBAN (Weather Bureau Army Navy) identifier. state property \u00b6 state : str US state in which the station is located. wban_ids property \u00b6 wban_ids : list [ str ] List of valid WBAN (Weather Bureau Army Navy) identifiers. years property \u00b6 years : list [ int ] Years for which data exists for the station. __repr__ \u00b6 __repr__ () String representation of a Station. Source code in riweather/stations.py 467 468 469 def __repr__ ( self ): \"\"\"String representation of a Station.\"\"\" return f 'Station(\" { self . usaf_id } \")' fetch_raw_temp_data \u00b6 fetch_raw_temp_data ( year = None , scale = 'C' ) Retrieve raw weather data from the ISD. Parameters: Name Type Description Default year int Returned data will be limited to the year specified. If None , data for all years is returned. None scale str Return the temperature in Celsius ( \"C\" , the default) or Fahrenheit ( \"F\" ). 'C' Returns: Type Description pd . DataFrame A DataFrame , indexed on the timestamp, with two columns: air temperature and dew point temperature. Examples: >>> s = Station ( \"720534\" ) >>> print ( s . fetch_raw_temp_data ( 2022 ) . head ( 2 )) tempC dewC 2022-01-01 00:15:00+00:00 -2.8 -4.0 2022-01-01 00:35:00+00:00 -4.2 -5.5 Source code in riweather/stations.py 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 def fetch_raw_temp_data ( self , year : int = None , scale : str = \"C\" ) -> pd . DataFrame : \"\"\"Retrieve raw weather data from the ISD. Args: year: Returned data will be limited to the year specified. If `None`, data for all years is returned. scale: Return the temperature in Celsius (`\"C\"`, the default) or Fahrenheit (`\"F\"`). Returns: A [DataFrame][pandas.DataFrame], indexed on the timestamp, with two columns: air temperature and dew point temperature. Examples: >>> s = Station(\"720534\") >>> print(s.fetch_raw_temp_data(2022).head(2)) tempC dewC 2022-01-01 00:15:00+00:00 -2.8 -4.0 2022-01-01 00:35:00+00:00 -4.2 -5.5 \"\"\" data = [] filenames = self . get_filenames ( year ) if scale not in ( \"C\" , \"F\" ): raise ValueError ( 'Scale must be \"C\" (Celsius) or \"F\" (Fahrenheit).' ) with NOAAFTPConnection () as conn : for filename in filenames : datastream = conn . read_file_as_bytes ( filename ) for line in datastream . readlines (): tempC = _parse_temp ( line [ 87 : 92 ]) dewC = _parse_temp ( line [ 93 : 98 ]) date_str = line [ 15 : 27 ] . decode ( \"utf-8\" ) dt = pytz . UTC . localize ( datetime . strptime ( date_str , \"%Y%m %d %H%M\" )) data . append ([ dt , tempC , dewC ]) timestamps , temps , dews = zip ( * sorted ( data ), strict = True ) ts = pd . DataFrame ({ \"tempC\" : temps , \"dewC\" : dews }, index = timestamps ) if scale == \"F\" : ts [ \"tempF\" ] = ts [ \"tempC\" ] * 1.8 + 32 ts [ \"dewF\" ] = ts [ \"dewC\" ] * 1.8 + 32 ts = ts . drop ([ \"tempC\" , \"dewC\" ], axis = \"columns\" ) ts = ts . groupby ( ts . index ) . mean () return ts fetch_temp_data \u00b6 fetch_temp_data ( year = None , value = None , scale = \"C\" , period = \"H\" , rollup = \"ending\" , upsample_first = True , ) Retrieve temperature data from the ISD. Parameters: Name Type Description Default year int Returned data will be limited to the year specified. If None , data for all years is returned. None value int \"temperature\" to retrieve the air temperature only, or \"dew_point\" to retrieve the dew point temperature only. None returns both temperatures in a DataFrame . None scale str Return the value(s) in Celsius ( \"C\" , the default) or Fahrenheit ( \"F\" ). 'C' period str The time step at which the data will be returned. Defaults to \"H\" , which corresponds to hourly data. Other possible values are \"30T\" or \"30min\" for half-hourly data, \"15T\" / \"15min\" for quarter-hourly data, and so on. See the Pandas documentation on frequency strings for more details on possible values. 'H' rollup str How to align values to the period . Defaults to \"ending\" , meaning that values over the previous time period are averaged. 'ending' upsample_first bool Whether to upsample the data to the minute level prior to resampling. Usually results in more accurate representations of the true weather data. True Returns: Type Description pd . DataFrame | pd . Series Either a DataFrame containing both air temperature and dew point temperature, or, if value was supplied, a Series containing one or the other. Examples: >>> s = Station ( \"720534\" ) >>> print ( s . fetch_temp_data ( 2022 ) . head ( 2 )) tempC dewC 2022-01-01 00:00:00+00:00 -4.298889 -5.512222 2022-01-01 01:00:00+00:00 -6.555833 -7.688333 Source code in riweather/stations.py 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 def fetch_temp_data ( self , year : int = None , value : int = None , scale : str = \"C\" , period : str = \"H\" , rollup : str = \"ending\" , upsample_first : bool = True , ) -> pd . DataFrame | pd . Series : \"\"\"Retrieve temperature data from the ISD. Args: year: Returned data will be limited to the year specified. If `None`, data for all years is returned. value: `\"temperature\"` to retrieve the air temperature only, or `\"dew_point\"` to retrieve the dew point temperature only. `None` returns both temperatures in a [DataFrame][pandas.DataFrame]. scale: Return the value(s) in Celsius (`\"C\"`, the default) or Fahrenheit (`\"F\"`). period: The time step at which the data will be returned. Defaults to `\"H\"`, which corresponds to hourly data. Other possible values are `\"30T\"` or `\"30min\"` for half-hourly data, `\"15T\"`/`\"15min\"` for quarter-hourly data, and so on. See the [Pandas documentation on frequency strings](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects) for more details on possible values. rollup: How to align values to the `period`. Defaults to `\"ending\"`, meaning that values over the previous time period are averaged. upsample_first: Whether to upsample the data to the minute level prior to resampling. Usually results in more accurate representations of the true weather data. Returns: Either a [DataFrame][pandas.DataFrame] containing both air temperature and dew point temperature, or, if `value` was supplied, a [Series][pandas.Series] containing one or the other. Examples: >>> s = Station(\"720534\") >>> print(s.fetch_temp_data(2022).head(2)) tempC dewC 2022-01-01 00:00:00+00:00 -4.298889 -5.512222 2022-01-01 01:00:00+00:00 -6.555833 -7.688333 \"\"\" # noqa if value is None : value = \"both\" elif value not in ( \"temperature\" , \"dew_point\" ): raise ValueError ( 'Value must be \"temperature\" or \"dew_point\"' ) if rollup not in ( \"starting\" , \"ending\" , \"midpoint\" , \"instant\" ): raise ValueError ( \"Invalid rollup\" ) raw_ts = self . fetch_raw_temp_data ( year , scale = scale ) if rollup == \"starting\" : ts = rollup_starting ( raw_ts , period , upsample_first = upsample_first ) elif rollup == \"ending\" : ts = rollup_ending ( raw_ts , period , upsample_first = upsample_first ) elif rollup == \"midpoint\" : ts = rollup_midpoint ( raw_ts , period , upsample_first = upsample_first ) else : # rollup == \"instant\" ts = rollup_instant ( raw_ts , period , upsample_first = upsample_first ) if value == \"temperature\" : return ts . loc [:, f \"temp { scale } \" ] if value == \"dew_point\" : return ts . loc [:, f \"dew { scale } \" ] else : return ts get_filenames \u00b6 get_filenames ( year = None ) Construct the names of ISD files corresponding to this station. Parameters: Name Type Description Default year int Limit the filenames to the one corresponding to the given year. If None , filenames for all years are returned. None Returns: Type Description list [ str ] List of filenames Examples: >>> s = Station ( \"720534\" ) >>> print ( s . get_filenames ( 2022 )) ['/pub/data/noaa/2022/720534-00161-2022.gz'] Source code in riweather/stations.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def get_filenames ( self , year : int = None ) -> list [ str ]: \"\"\"Construct the names of ISD files corresponding to this station. Args: year: Limit the filenames to the one corresponding to the given year. If `None`, filenames for all years are returned. Returns: List of filenames Examples: >>> s = Station(\"720534\") >>> print(s.get_filenames(2022)) ['/pub/data/noaa/2022/720534-00161-2022.gz'] \"\"\" stmt = select ( models . FileCount ) . where ( models . FileCount . station_id == self . _station . get ( \"id\" ) ) if year is not None : stmt = stmt . where ( models . FileCount . year == year ) filename_template = \"/pub/data/noaa/ {2} / {0} - {1} - {2} .gz\" filenames = [] with MetadataSession () as session : for row in session . scalars ( stmt ): filenames . append ( filename_template . format ( self . usaf_id , row . wban_id , row . year ) ) return filenames quality_report \u00b6 quality_report ( year = None ) Retrieve information on data quality. Parameters: Name Type Description Default year int Limit the report to information concerning the given year. If None , all years are included. None Returns: Type Description pd . DataFrame | pd . Series Data quality report Source code in riweather/stations.py 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 def quality_report ( self , year : int = None ) -> pd . DataFrame | pd . Series : \"\"\"Retrieve information on data quality. Args: year: Limit the report to information concerning the given year. If `None`, all years are included. Returns: Data quality report \"\"\" stmt = select ( models . FileCount ) . where ( models . FileCount . station_id == self . _station . get ( \"id\" ) ) if year is not None : stmt = stmt . where ( models . FileCount . year == year ) with MetadataSession () as session : results = [ { \"usaf_id\" : r . station . usaf_id , \"wban_id\" : r . wban_id , \"year\" : r . year , \"quality\" : r . quality , \"jan\" : r . jan , \"feb\" : r . feb , \"mar\" : r . mar , \"apr\" : r . apr , \"may\" : r . may , \"jun\" : r . jun , \"jul\" : r . jul , \"aug\" : r . aug , \"sep\" : r . sep , \"oct\" : r . oct , \"nov\" : r . nov , \"dec\" : r . dec , \"count\" : r . count , \"n_zero_months\" : r . n_zero_months , } for r in session . scalars ( stmt ) . all () ] return pd . DataFrame ( results ) . squeeze ()","title":"API Reference"},{"location":"reference/#api-reference","text":"","title":"API Reference"},{"location":"reference/#riweather","text":"riweather. Grab publicly available weather data.","title":"riweather"},{"location":"reference/#riweather.plot_stations","text":"plot_stations ( lat , lon , ranked_stations , * , n = None , distance_unit = \"m\" ) Plot stations relative to a location. Raises: Type Description ImportError If matplotlib and folium are not installed. Parameters: Name Type Description Default lat float Site latitude required lon float Site longitude required ranked_stations pd . DataFrame Ranked stations required n int The n top-ranked stations of ranked_stations will be plotted None distance_unit str Distance unit to use on the plot. Must be meters ( m ), kilometers ( km ), or miles ( mi ) 'm' Source code in riweather/viz.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def plot_stations ( lat : float , lon : float , ranked_stations : pd . DataFrame , * , n : int = None , distance_unit : str = \"m\" , ): \"\"\"Plot stations relative to a location. Raises: ImportError: If [matplotlib][] and [folium](https://python-visualization.github.io/folium/) are not installed. Args: lat: Site latitude lon: Site longitude ranked_stations: Ranked stations n: The ``n`` top-ranked stations of ``ranked_stations`` will be plotted distance_unit: Distance unit to use on the plot. Must be meters (``m``), kilometers (``km``), or miles (``mi``) \"\"\" try : import matplotlib.pyplot as plt # noqa except ImportError : raise ImportError ( \"Plotting stations requires matplotlib\" ) from None try : import folium except ImportError : raise ImportError ( \"Plotting stations requires folium\" ) from None if n is None : n = ranked_stations . shape [ 0 ] station_info = ranked_stations . head ( n ) m = folium . Map ( location = [ lat , lon ]) folium . Marker ([ lat , lon ], popup = \"Site\" ) . add_to ( m ) for row in station_info . itertuples (): folium . Marker ( [ row . latitude , row . longitude ], popup = row . name , icon = folium . Icon ( icon = \"cloud\" ), ) . add_to ( m ) folium . PolyLine ( [[ lat , lon ], [ row . latitude , row . longitude ]], popup = _calculate_distance_labels ( row . distance , distance_unit ), ) . add_to ( m ) return m","title":"plot_stations()"},{"location":"reference/#riweather.rank_stations","text":"rank_stations ( lat , lon , * , year = None , max_distance_m = None ) Rank stations by distance to a point. Parameters: Name Type Description Default lat float Site latitude required lon float Site longitude required year int If specified, only include stations with data for the given year(s). None max_distance_m int If specified, only include stations within this distance (in meters) from the site. None Returns: Type Description pd . DataFrame A DataFrame of station information. Source code in riweather/stations.py 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 def rank_stations ( lat : float , lon : float , * , year : int = None , max_distance_m : int = None ) -> pd . DataFrame : \"\"\"Rank stations by distance to a point. Args: lat: Site latitude lon: Site longitude year: If specified, only include stations with data for the given year(s). max_distance_m: If specified, only include stations within this distance (in meters) from the site. Returns: A [DataFrame][pandas.DataFrame] of station information. \"\"\" station_info = { info [ \"usaf_id\" ]: info for info in _calculate_distances ( lat , lon )} results = ( select ( models . Station . usaf_id , models . Station . name , models . FileCount . year , models . FileCount . quality , ) . join_from ( models . Station , models . FileCount , ) . where ( models . Station . usaf_id . in_ ( station_info . keys ())) ) data = {} with MetadataSession () as session : for row in session . execute ( results ): if row . usaf_id not in data . keys (): data [ row . usaf_id ] = { ** station_info [ row . usaf_id ], \"years\" : [], \"quality\" : [], } data [ row . usaf_id ][ \"years\" ] . append ( row . year ) data [ row . usaf_id ][ \"quality\" ] . append ( row . quality ) data = pd . DataFrame ( sorted ( data . values (), key = operator . itemgetter ( \"distance\" )) ) . set_index ( \"usaf_id\" ) if year is not None : def _filter_years ( x ): if isinstance ( year , list ): return all ( y in x for y in year ) else : return year in x data = data . loc [ data [ \"years\" ] . apply ( _filter_years ), :] if max_distance_m is not None : data = data . loc [ data [ \"distance\" ] <= max_distance_m , :] return data","title":"rank_stations()"},{"location":"reference/#riweather.select_station","text":"select_station ( ranked_stations , rank = 0 ) Return a Station object out of a ranked set of stations. Parameters: Name Type Description Default ranked_stations pd . DataFrame A DataFrame returned by [ riweather.rank_stations ]. required rank int Which station to return. Defaults to rank=0 , which corresponds to the first (i.e. nearest) station. 0 Returns: Type Description Station A Station object. Source code in riweather/stations.py 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 def select_station ( ranked_stations : pd . DataFrame , rank : int = 0 ) -> Station : \"\"\"Return a Station object out of a ranked set of stations. Args: ranked_stations: A [DataFrame][pandas.DataFrame] returned by [`riweather.rank_stations`]. rank: Which station to return. Defaults to `rank=0`, which corresponds to the first (i.e. nearest) station. Returns: A [`Station`][riweather.Station] object. \"\"\" if len ( ranked_stations ) <= rank : raise ValueError ( \"Rank too large, not enough stations\" ) ranked_stations = ranked_stations . sort_values ( \"distance\" ) station = ranked_stations . iloc [ rank ] return Station ( usaf_id = station . name )","title":"select_station()"},{"location":"reference/#riweather.zcta_to_lat_lon","text":"zcta_to_lat_lon ( zcta ) Convert zip code to lat/lon. Parameters: Name Type Description Default zcta str Five-digit zip code required Returns: Type Description float , float The center point of the ZCTA (Zip Code Tabulation Area). Source code in riweather/stations.py 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 def zcta_to_lat_lon ( zcta : str ) -> ( float , float ): \"\"\"Convert zip code to lat/lon. Args: zcta: Five-digit zip code Returns: The center point of the ZCTA (Zip Code Tabulation Area). \"\"\" with MetadataSession () as session : zcta = session . scalars ( select ( models . Zcta ) . where ( models . Zcta . zip == zcta ) ) . first () return zcta . latitude , zcta . longitude","title":"zcta_to_lat_lon()"},{"location":"reference/#riweather.Station","text":"Station ( usaf_id , load_metadata_on_init = True ) ISD Station object. Parameters: Name Type Description Default usaf_id str USAF identifier required load_metadata_on_init bool If True , station metadata will be retrieved from the local data store and loaded into the object as properties. True Examples: >>> s = Station ( \"720534\" ) >>> print ( s . name , s . latitude , s . longitude ) ERIE MUNICIPAL AIRPORT 40.017 -105.05 Source code in riweather/stations.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def __init__ ( self , usaf_id : str , load_metadata_on_init : bool = True ): \"\"\"ISD Station object. Args: usaf_id: USAF identifier load_metadata_on_init: If `True`, station metadata will be retrieved from the local data store and loaded into the object as properties. Examples: >>> s = Station(\"720534\") >>> print(s.name, s.latitude, s.longitude) ERIE MUNICIPAL AIRPORT 40.017 -105.05 \"\"\" self . usaf_id = usaf_id if load_metadata_on_init : self . _station = self . _load_metadata () else : self . _station = {}","title":"Station"},{"location":"reference/#riweather.stations.Station.elevation","text":"elevation : float Elevation of the station, in meters.","title":"elevation"},{"location":"reference/#riweather.stations.Station.icao_code","text":"icao_code : str ICAO airport code.","title":"icao_code"},{"location":"reference/#riweather.stations.Station.latitude","text":"latitude : float Station latitude.","title":"latitude"},{"location":"reference/#riweather.stations.Station.longitude","text":"longitude : float Station longitude.","title":"longitude"},{"location":"reference/#riweather.stations.Station.name","text":"name : str Station name.","title":"name"},{"location":"reference/#riweather.stations.Station.recent_wban_id","text":"recent_wban_id : str Most recent WBAN (Weather Bureau Army Navy) identifier.","title":"recent_wban_id"},{"location":"reference/#riweather.stations.Station.state","text":"state : str US state in which the station is located.","title":"state"},{"location":"reference/#riweather.stations.Station.wban_ids","text":"wban_ids : list [ str ] List of valid WBAN (Weather Bureau Army Navy) identifiers.","title":"wban_ids"},{"location":"reference/#riweather.stations.Station.years","text":"years : list [ int ] Years for which data exists for the station.","title":"years"},{"location":"reference/#riweather.stations.Station.__repr__","text":"__repr__ () String representation of a Station. Source code in riweather/stations.py 467 468 469 def __repr__ ( self ): \"\"\"String representation of a Station.\"\"\" return f 'Station(\" { self . usaf_id } \")'","title":"__repr__()"},{"location":"reference/#riweather.stations.Station.fetch_raw_temp_data","text":"fetch_raw_temp_data ( year = None , scale = 'C' ) Retrieve raw weather data from the ISD. Parameters: Name Type Description Default year int Returned data will be limited to the year specified. If None , data for all years is returned. None scale str Return the temperature in Celsius ( \"C\" , the default) or Fahrenheit ( \"F\" ). 'C' Returns: Type Description pd . DataFrame A DataFrame , indexed on the timestamp, with two columns: air temperature and dew point temperature. Examples: >>> s = Station ( \"720534\" ) >>> print ( s . fetch_raw_temp_data ( 2022 ) . head ( 2 )) tempC dewC 2022-01-01 00:15:00+00:00 -2.8 -4.0 2022-01-01 00:35:00+00:00 -4.2 -5.5 Source code in riweather/stations.py 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 def fetch_raw_temp_data ( self , year : int = None , scale : str = \"C\" ) -> pd . DataFrame : \"\"\"Retrieve raw weather data from the ISD. Args: year: Returned data will be limited to the year specified. If `None`, data for all years is returned. scale: Return the temperature in Celsius (`\"C\"`, the default) or Fahrenheit (`\"F\"`). Returns: A [DataFrame][pandas.DataFrame], indexed on the timestamp, with two columns: air temperature and dew point temperature. Examples: >>> s = Station(\"720534\") >>> print(s.fetch_raw_temp_data(2022).head(2)) tempC dewC 2022-01-01 00:15:00+00:00 -2.8 -4.0 2022-01-01 00:35:00+00:00 -4.2 -5.5 \"\"\" data = [] filenames = self . get_filenames ( year ) if scale not in ( \"C\" , \"F\" ): raise ValueError ( 'Scale must be \"C\" (Celsius) or \"F\" (Fahrenheit).' ) with NOAAFTPConnection () as conn : for filename in filenames : datastream = conn . read_file_as_bytes ( filename ) for line in datastream . readlines (): tempC = _parse_temp ( line [ 87 : 92 ]) dewC = _parse_temp ( line [ 93 : 98 ]) date_str = line [ 15 : 27 ] . decode ( \"utf-8\" ) dt = pytz . UTC . localize ( datetime . strptime ( date_str , \"%Y%m %d %H%M\" )) data . append ([ dt , tempC , dewC ]) timestamps , temps , dews = zip ( * sorted ( data ), strict = True ) ts = pd . DataFrame ({ \"tempC\" : temps , \"dewC\" : dews }, index = timestamps ) if scale == \"F\" : ts [ \"tempF\" ] = ts [ \"tempC\" ] * 1.8 + 32 ts [ \"dewF\" ] = ts [ \"dewC\" ] * 1.8 + 32 ts = ts . drop ([ \"tempC\" , \"dewC\" ], axis = \"columns\" ) ts = ts . groupby ( ts . index ) . mean () return ts","title":"fetch_raw_temp_data()"},{"location":"reference/#riweather.stations.Station.fetch_temp_data","text":"fetch_temp_data ( year = None , value = None , scale = \"C\" , period = \"H\" , rollup = \"ending\" , upsample_first = True , ) Retrieve temperature data from the ISD. Parameters: Name Type Description Default year int Returned data will be limited to the year specified. If None , data for all years is returned. None value int \"temperature\" to retrieve the air temperature only, or \"dew_point\" to retrieve the dew point temperature only. None returns both temperatures in a DataFrame . None scale str Return the value(s) in Celsius ( \"C\" , the default) or Fahrenheit ( \"F\" ). 'C' period str The time step at which the data will be returned. Defaults to \"H\" , which corresponds to hourly data. Other possible values are \"30T\" or \"30min\" for half-hourly data, \"15T\" / \"15min\" for quarter-hourly data, and so on. See the Pandas documentation on frequency strings for more details on possible values. 'H' rollup str How to align values to the period . Defaults to \"ending\" , meaning that values over the previous time period are averaged. 'ending' upsample_first bool Whether to upsample the data to the minute level prior to resampling. Usually results in more accurate representations of the true weather data. True Returns: Type Description pd . DataFrame | pd . Series Either a DataFrame containing both air temperature and dew point temperature, or, if value was supplied, a Series containing one or the other. Examples: >>> s = Station ( \"720534\" ) >>> print ( s . fetch_temp_data ( 2022 ) . head ( 2 )) tempC dewC 2022-01-01 00:00:00+00:00 -4.298889 -5.512222 2022-01-01 01:00:00+00:00 -6.555833 -7.688333 Source code in riweather/stations.py 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 def fetch_temp_data ( self , year : int = None , value : int = None , scale : str = \"C\" , period : str = \"H\" , rollup : str = \"ending\" , upsample_first : bool = True , ) -> pd . DataFrame | pd . Series : \"\"\"Retrieve temperature data from the ISD. Args: year: Returned data will be limited to the year specified. If `None`, data for all years is returned. value: `\"temperature\"` to retrieve the air temperature only, or `\"dew_point\"` to retrieve the dew point temperature only. `None` returns both temperatures in a [DataFrame][pandas.DataFrame]. scale: Return the value(s) in Celsius (`\"C\"`, the default) or Fahrenheit (`\"F\"`). period: The time step at which the data will be returned. Defaults to `\"H\"`, which corresponds to hourly data. Other possible values are `\"30T\"` or `\"30min\"` for half-hourly data, `\"15T\"`/`\"15min\"` for quarter-hourly data, and so on. See the [Pandas documentation on frequency strings](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects) for more details on possible values. rollup: How to align values to the `period`. Defaults to `\"ending\"`, meaning that values over the previous time period are averaged. upsample_first: Whether to upsample the data to the minute level prior to resampling. Usually results in more accurate representations of the true weather data. Returns: Either a [DataFrame][pandas.DataFrame] containing both air temperature and dew point temperature, or, if `value` was supplied, a [Series][pandas.Series] containing one or the other. Examples: >>> s = Station(\"720534\") >>> print(s.fetch_temp_data(2022).head(2)) tempC dewC 2022-01-01 00:00:00+00:00 -4.298889 -5.512222 2022-01-01 01:00:00+00:00 -6.555833 -7.688333 \"\"\" # noqa if value is None : value = \"both\" elif value not in ( \"temperature\" , \"dew_point\" ): raise ValueError ( 'Value must be \"temperature\" or \"dew_point\"' ) if rollup not in ( \"starting\" , \"ending\" , \"midpoint\" , \"instant\" ): raise ValueError ( \"Invalid rollup\" ) raw_ts = self . fetch_raw_temp_data ( year , scale = scale ) if rollup == \"starting\" : ts = rollup_starting ( raw_ts , period , upsample_first = upsample_first ) elif rollup == \"ending\" : ts = rollup_ending ( raw_ts , period , upsample_first = upsample_first ) elif rollup == \"midpoint\" : ts = rollup_midpoint ( raw_ts , period , upsample_first = upsample_first ) else : # rollup == \"instant\" ts = rollup_instant ( raw_ts , period , upsample_first = upsample_first ) if value == \"temperature\" : return ts . loc [:, f \"temp { scale } \" ] if value == \"dew_point\" : return ts . loc [:, f \"dew { scale } \" ] else : return ts","title":"fetch_temp_data()"},{"location":"reference/#riweather.stations.Station.get_filenames","text":"get_filenames ( year = None ) Construct the names of ISD files corresponding to this station. Parameters: Name Type Description Default year int Limit the filenames to the one corresponding to the given year. If None , filenames for all years are returned. None Returns: Type Description list [ str ] List of filenames Examples: >>> s = Station ( \"720534\" ) >>> print ( s . get_filenames ( 2022 )) ['/pub/data/noaa/2022/720534-00161-2022.gz'] Source code in riweather/stations.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def get_filenames ( self , year : int = None ) -> list [ str ]: \"\"\"Construct the names of ISD files corresponding to this station. Args: year: Limit the filenames to the one corresponding to the given year. If `None`, filenames for all years are returned. Returns: List of filenames Examples: >>> s = Station(\"720534\") >>> print(s.get_filenames(2022)) ['/pub/data/noaa/2022/720534-00161-2022.gz'] \"\"\" stmt = select ( models . FileCount ) . where ( models . FileCount . station_id == self . _station . get ( \"id\" ) ) if year is not None : stmt = stmt . where ( models . FileCount . year == year ) filename_template = \"/pub/data/noaa/ {2} / {0} - {1} - {2} .gz\" filenames = [] with MetadataSession () as session : for row in session . scalars ( stmt ): filenames . append ( filename_template . format ( self . usaf_id , row . wban_id , row . year ) ) return filenames","title":"get_filenames()"},{"location":"reference/#riweather.stations.Station.quality_report","text":"quality_report ( year = None ) Retrieve information on data quality. Parameters: Name Type Description Default year int Limit the report to information concerning the given year. If None , all years are included. None Returns: Type Description pd . DataFrame | pd . Series Data quality report Source code in riweather/stations.py 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 def quality_report ( self , year : int = None ) -> pd . DataFrame | pd . Series : \"\"\"Retrieve information on data quality. Args: year: Limit the report to information concerning the given year. If `None`, all years are included. Returns: Data quality report \"\"\" stmt = select ( models . FileCount ) . where ( models . FileCount . station_id == self . _station . get ( \"id\" ) ) if year is not None : stmt = stmt . where ( models . FileCount . year == year ) with MetadataSession () as session : results = [ { \"usaf_id\" : r . station . usaf_id , \"wban_id\" : r . wban_id , \"year\" : r . year , \"quality\" : r . quality , \"jan\" : r . jan , \"feb\" : r . feb , \"mar\" : r . mar , \"apr\" : r . apr , \"may\" : r . may , \"jun\" : r . jun , \"jul\" : r . jul , \"aug\" : r . aug , \"sep\" : r . sep , \"oct\" : r . oct , \"nov\" : r . nov , \"dec\" : r . dec , \"count\" : r . count , \"n_zero_months\" : r . n_zero_months , } for r in session . scalars ( stmt ) . all () ] return pd . DataFrame ( results ) . squeeze ()","title":"quality_report()"}]}